<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修第五周（web，machine learning笔记）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>第五周（web，machine learning笔记）</center></div><div class='banquan'>原文出处:本文由博客园博主xenia&amp;diaries提供。<br/>
原文连接:https://www.cnblogs.com/xkeepgoing/p/11785112.html</div><br>
    <p>2019/11/2</p>
<p>1、&nbsp;&nbsp;&nbsp; 表现层状态转换（REST, representational state transfer.）一种<a title="万维网" href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91">万维网</a><a title="软件架构" href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84">软件架构</a>风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。表现层状态转换是根基于<a title="超文本传输协议" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">超文本传输协议(HTTP)</a>之上而确定的一组约束和属性，是一种设计提供万维网络服务的<a title="软件架构" href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E6%9E%B6%E6%A7%8B">软件构建风格</a>。符合或兼容于这种架构风格(简称为 REST 或 RESTful)的网络服务，允许客户端发出以<a title="统一资源标志符" href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6">统一资源标识符</a>访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。因此表现层状态转换提供了在互联网络的计算系统之间，彼此资源可交互使用的协作性质(interoperability)。</p>
<p>REST是设计风格而<strong>不是</strong>标准。REST通常基于使用<a title="HTTP" href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>，<a title="URI" href="https://zh.wikipedia.org/wiki/URI">URI</a>，和<a title="XML" href="https://zh.wikipedia.org/wiki/XML">XML</a>以及<a title="HTML" href="https://zh.wikipedia.org/wiki/HTML">HTML</a>这些现有的广泛流行的协议和标准。</p>
<ul>
<li>资源是由URI来指定。</li>
<li>对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。</li>
<li>通过操作资源的表现形式来操作资源。</li>
<li>资源的表现形式则是XML或者HTML，取决于读者是机器还是人，是消费web服务的客户软件还是web浏览器。当然也可以是任何其他的格式，例如JSON。</li>
</ul>
<p>REST架构风格最重要的架构约束有6个<sup><a href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2#cite_note-2">[2]</a></sup>：</p>
<ul>
<li>客户端-服务器（Client-Server）</li>
</ul>
<p>客户端-服务器结构约束的目的是将客户端和服务器端的关注点分离. 将用户界面所关注的逻辑和数据存储所关注的逻辑分离开来有助于提高用户界面的跨平台的可移植性.通过简化服务器模块也有助于服务器模块的可扩展性.</p>
<ul>
<li>无状态（Stateless）</li>
</ul>
<p>服务器不能保存客户端的信息, 每一次从客户端发送的请求中, 要包含所有的必须的状态信息, 会话信息由客户端保存, 服务器端根据这些状态信息来处理请求. 服务器可以将会话状态信息传递给其他服务, 比如数据库服务, 这样可以保持一段时间的状态信息, 从而实现认证功能. 当客户端可以切换到一个新状态的时候发送请求信息. 当一个或者多个请求被发送之后, 客户端就处于一个状态变迁过程中. 每一个应用的状态描述可以被客户端用来初始化下一次的状态变迁.</p>
<ul>
<li>缓存（Cacheability）</li>
</ul>
<p>如同万维网一样, 客户端和中间的通讯传递者可以将响应缓存起来. 响应必须明确的或者间接的表明本身是否可以进行缓存,这可以预防客户端在将来进行请求的时候得到陈旧的或者不恰当的数据. 管理良好的缓存机制可以 减少客户端-服务器之间的交互, 甚至完全避免客户端-服务器交互, 这进一步提了高性能和可扩展性。</p>
<ul>
<li>统一接口（Uniform Interface）</li>
</ul>
<p>统一接口是 RESTful 系统设计的基本出发点. 它简化了系统的架构, 减少了耦合性, 可以让所有模块各自独立的进行改进. 对于统一接口的四个约束是:</p>
<ul>
<li>请求中包含资源的 ID (Resource identification in requests )</li>
</ul>
<p>请求中包含了各种独立资源的标识, 例如, 在 Web 服务中的 URIs. 资源本身和发送给客户端的标识是独立. 例如, 服务器可以将自身的数据库信息以 HTML XML 或者 JSON 的方式发送给客户端, 但是这些可能都不是服务器的内部记录方式.</p>
<ul>
<li>资源通过标识来操作(Resource manipulation through representations)</li>
</ul>
<p>当客户端拥有一个资源的标识, 包括附带的元数据, 则它就有足够的信息来删除这个资源.</p>
<ul>
<li>消息的自我描述性(Self-descriptive messages)</li>
</ul>
<p>每一个消息都包含足够的信息来描述如何来处理这个信息. 例如, 媒体类型 (midia-type) 就可以确定需要什么样的分析器来分析媒体数据.</p>
<ul>
<li>用超媒体驱动应用状态 ( Hypermedia as the engine of application state (HATEOAS))</li>
</ul>
<p>同用户访问 Web 服务器的 Home 页面相似,当一个 REST 客户端访问了最初的 REST 应用的 URI 之后, REST 客户端应该可以使用服务器端提供的链接,动态的发现所有的可用的资源和可执行的操作.随着访问的进行, 服务器在响应中提供文字超链接, 以便客户端可以得到当前可用的操作. 客户端无需用确定的编码的方式记录下服务器端所提供的动态应用的结构信息.</p>
<ul>
<li>分层系统（Layered System）</li>
</ul>
<p>客户端一般不知道是否直接连接到了最终的服务器, 或者是路径上的中间服务器. 中间服务器可以通过负载均衡和共享缓存的机制提高系统的可扩展性,这样可也便于安全策略的部署.</p>
<ul>
<li>按需代码（Code-On-Demand，可选）</li>
</ul>
<p>服务器可以通过发送可执行代码给客户端的方式临时性的扩展功能或者定制功能.例如Java Applet、Flash或JavaScript。</p>
<p>2、&nbsp; Building an&nbsp;<strong>Ensemble Learning</strong>&nbsp;Model Using&nbsp;<strong>Scikit</strong>-<strong>learn</strong>.&nbsp;<strong>Ensemble learning</strong>&nbsp;uses multiple&nbsp;<strong>machine learning</strong>&nbsp;models to try to make better predictions on a dataset. An&nbsp;<strong>ensemble</strong>&nbsp;model works by training different models on a dataset and having each model make predictions individually.</p>
<p>3、&nbsp; <strong>Gradient boosting</strong>&nbsp;is a machine learning technique for regression and classification problems, which produces a prediction model in the form of an ensemble of weak prediction models, typically decision trees. 梯度提升是一种针对回归和分类问题的机器学习技术，它以弱预测模型的集合（通常为决策树）的形式生成预测模型。像其他增强方法一样，它以分阶段的方式构建模型，并通过允许对任意可微分的损失函数进行优化来对其进行概括。 梯度增强的思想源自Leo Breiman的观察，即可以将增强解释为针对适当成本函数的优化算法。</p>
<p>4、&nbsp; <strong>提升方法</strong>（Boosting），是一种可以用来减小<a title="监督式学习" href="https://zh.wikipedia.org/wiki/%E7%9B%A3%E7%9D%A3%E5%BC%8F%E5%AD%B8%E7%BF%92">监督式学习</a>中<a title="偏差" href="https://zh.wikipedia.org/wiki/%E5%81%8F%E5%B7%AE">偏差</a>的<a title="机器学习" href="https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0">机器学习</a>算法。</p>
<p>5、&nbsp; AdaBoost，是英文"Adaptive Boosting"（自适应增强）的缩写。AdaBoost方法的自适应在于：前一个分类器分错的样本会被用来训练下一个分类器。对于噪声数据和异常数据很敏感。AdaBoost方法是一种迭代算法，在每一轮中加入一个新的弱分类器，直到达到某个预定的足够小的错误率。</p>
<p>6、&nbsp; 由于<strong>递归</strong>引起一系列的函数调用,并且有可能会有一系列的重复计算,<strong>递归</strong>算法的执行效率相对较低.&nbsp;<strong>迭代</strong>:利用变量的原值推算出变量的一个新值. 如果<strong>递归</strong>是自己调用自己的话,<strong>迭代</strong>就是A不停的调用B. 所谓<strong>递归</strong>，简而言之就是应用程序自身调用自身，以实现层次数据结构的查询和访问。</p>
<p>7、&nbsp; <strong>枚举</strong>(enumeration)，在数学和计算机科学理论中，一个集的枚举是列出某些有穷序列集的所有成员的程序，或者是一种特定类型对象的计数。这两种类型经常（但不总是）重叠。枚举是一个被命名的整型常数的集合！<strong>遍历</strong>（traversal），是树形结构的一种重要运算，指的是按照一定的规则访问树形结构中的每个节点，而且每个节点都只访问一次。<strong>迭代</strong>（iterate），指的是按照某种顺序逐个访问列表中的每一项。<strong>迭代</strong>是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。 每一次对过程的重复被称为一次&ldquo;<strong>迭代</strong>&rdquo;，而每一次<strong>迭代</strong>得到的结果会被用来作为下一次<strong>迭代</strong>的初始值。<strong>循环</strong>(loop)：指的是在满足条件的情况下，重复执行同一段代码。一般语言都会有三种类型的循环语句:for语句、while语句和do While语句。<strong>递归函数</strong>(Recursion function)：是在一个函数通过名字调用自身的情况下构成的。<strong>递归</strong>(recursion)在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。递归一词还较常用于描述以自相似方法重复事物的过程。</p>
<p>8、&nbsp; <strong>递归：</strong><strong>recursion</strong><strong>，</strong><strong>典型例子，阶乘，挪大小盘子的问题（河内塔？）</strong></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>