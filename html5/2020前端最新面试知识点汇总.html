<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修2020前端最新面试知识点汇总' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>2020前端最新面试知识点汇总</center></div><div class='banquan'>原文出处:本文由博客园博主.伊泽瑞尔提供。<br/>
原文连接:https://www.cnblogs.com/7Ezreal/p/11981103.html</div><br>
    <p>前言：最近在找工作，自己整理了一些前端面试知识点，在此与大家分享一下！</p>
<p>1.前端需要注意哪些 SEO：<br />    合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可<br />    语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页<br />    重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取<br />    重要内容不要用 js 输出：爬虫不会执行 js 获取内容<br />    少用 iframe：搜索引擎不会抓取 iframe 中的内容<br />    非装饰性图片必须加 alt<br />    提高网站速度：网站速度是搜索引擎排序的一个重要指标</p>
<p>2.&lt;img&gt;的title和alt有什么区别：<br />    title是global attributes之一，通常当鼠标滑动到元素上的时候显示。    <br />    alt是&lt;img&gt;的特有属性，是图片内容的等价描述，用于图片无法加载时显示，搜索引擎会重点分析。<br />	<br />3.什么是 web 语义化,有什么好处：<br />    web 语义化是指通过 HTML 标记表示页面包含的信息，包含了 HTML 标签的语义化和 css 命名的语义化。 HTML 标签的语义化是指：通过使用包含语义的标签（如 h1-h6）恰当地表示文档结构 css 命名的语义化是指：为 html 标签添加有意义的 class，id 补充未表达的语义：<br />    去掉样式后页面呈现清晰的结构<br />    盲人使用读屏器更好地阅读<br />    搜索引擎更好地理解页面，有利于收录<br />    便团队项目的可持续运作及维护</p>
<p>4.HTTP method<br />    一台服务器要与 HTTP1.1 兼容，只要为资源实现GET和HEAD方法即可<br />    GET是最常用的方法，通常用于请求服务器发送某个资源。<br />    HEAD与 GET 类似，但服务器在响应中值返回首部，不返回实体的主体部分<br />    PUT让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用干这个主体替代它<br />    POST起初是用来向服务器输入数据的。实际上，通常会用它来支持 HTML 的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。<br />    TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个 TRACE 响应并在响应主体中携带它收到的原始请求报文。TRACE 方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。<br />    OPTIONS方法请求 web 服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。<br />    DELETE请求服务器删除请求 URL 指定的资源</p>
<p>5.从浏览器地址栏输入 url 到显示页面的步骤(以 HTTP 为例)<br />    在浏览器地址栏输入 URL<br />    浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤<br />        如果资源未缓存，发起新请求<br />        如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。<br />        检验新鲜通常有两个 HTTP 头进行控制Expires和Cache-Control：<br />            HTTP1.0 提供 Expires，值为一个绝对时间表示缓存新鲜日期<br />            HTTP1.1 增加了 Cache-Control: max-age=,值为以秒为单位的最大新鲜时间<br />		浏览器解析 URL获取协议，主机，端口，path<br />		浏览器组装一个 HTTP（GET）请求报文<br />		浏览器获取主机 ip 地址<br />		打开一个 socket 与目标 IP 地址，端口建立 TCP 链接，三次握手如下：</p>
<p>			客户端发送一个 TCP 的SYN=1，Seq=X的包到服务器端口<br />			服务器发回SYN=1， ACK=X+1， Seq=Y的响应包<br />			客户端发送ACK=Y+1， Seq=Z</p>
<p>		TCP 链接建立后发送 HTTP 请求<br />		服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用 HTTP Host 头部判断请求的服务程序<br />		服务器检查HTTP 请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码<br />		处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作<br />		服务器将响应报文通过 TCP 连接发送回浏览器<br />		浏览器接收 HTTP 响应，然后根据情况选择关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次握手如下：</p>
<p>			主动方发送Fin=1， Ack=Z， Seq= X报文<br />			被动方发送ACK=X+1， Seq=Z报文<br />			被动方发送Fin=1， ACK=X， Seq=Y报文<br />			主动方发送ACK=Y， Seq=X报文</p>
<p>		浏览器检查响应状态吗：是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同<br />		如果资源可缓存，进行缓存<br />		对响应进行解码（例如 gzip 压缩）<br />		根据资源类型决定如何处理（假设资源为 HTML 文档）<br />		解析 HTML 文档，构件 DOM 树，下载资源，构造 CSSOM 树，执行 js 脚本，这些操作没有严格的先后顺序，以下分别解释<br />		构建 DOM 树：</p>
<p>		解析过程中遇到图片、样式表、js 文件，启动下载<br />		构建CSSOM 树：</p>
<p>		根据 DOM 树和 CSSOM 树构建渲染树:</p>
<p>			从 DOM 树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被 css 隐藏的节点，如display: none<br />			对每一个可见节点，找到恰当的 CSSOM 规则并应用<br />			发布可视节点的内容和计算样式</p>
<p>		js 解析如下：</p>
<p>			浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate 为 loading<br />			HTML 解析器遇到没有 async 和 defer 的 script 时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容<br />			当解析器遇到设置了async属性的 script 时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用 document.write()，它们可以访问自己 script 和之前的文档元素<br />			当文档完成解析，document.readState 变成 interactive<br />			所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用 document.write()<br />			浏览器在 Document 对象上触发 DOMContentLoaded 事件<br />			此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState 变为 complete,window 触发 load 事件</p>
<p>		显示页面（HTML 解析过程中会逐步显示页面）	</p>
<p>6.HTTP request 报文结构是怎样的<br />    首行是Request-Line包括：请求方法，请求 URI，协议版本，CRLF（回车换行）<br />    首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以 CRLF 结束<br />    请求头和消息实体之间有一个CRLF 分隔<br />    根据实际请求需要可能包含一个消息实体</p>
<p>7.HTTP response 报文结构是怎样的<br />    首行是状态行包括：HTTP 版本，状态码，状态描述，后面跟一个 CRLF<br />    首行之后是若干行响应头，包括：通用头部，响应头部，实体头部<br />    响应头部和响应实体之间用一个 CRLF 空行分隔<br />    最后是一个可能的消息实体<br />	<br />8.如何进行网站性能优化<br />    content 方面<br />        减少 HTTP 请求：合并文件、CSS 精灵、inline Image<br />        减少 DNS 查询：DNS 查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS 缓存、将资源分布到恰当数量的主机名，平衡并行下载和 DNS 查询<br />        避免重定向：多余的中间访问<br />        使 Ajax 可缓存<br />        非必须组件延迟加载<br />        未来所需组件预加载<br />        减少 DOM 元素数量<br />        将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量<br />        减少 iframe 数量<br />        不要 404</p>
<p>    Server 方面<br />        使用 CDN<br />        添加 Expires 或者 Cache-Control 响应头<br />        对组件使用 Gzip 压缩<br />        配置 ETag<br />        Flush Buffer Early<br />        Ajax 使用 GET 进行请求<br />        避免空 src 的 img 标签</p>
<p>    Cookie 方面<br />        减小 cookie 大小<br />        引入资源的域名不要包含 cookie</p>
<p>    css 方面<br />        将样式表放到页面顶部<br />        不使用 CSS 表达式<br />        使用不使用@import<br />        不使用 IE 的 Filter</p>
<p>    Javascript 方面<br />        将脚本放到页面底部<br />        将 javascript 和 css 从外部引入<br />        压缩 javascript 和 css<br />        删除不需要的脚本<br />        减少 DOM 访问<br />        合理设计事件监听器</p>
<p>    图片方面<br />        优化图片：根据实际颜色需要选择色深、压缩<br />        优化 css 精灵<br />        不要在 HTML 中拉伸图片<br />        保证 favicon.ico 小并且可缓存</p>
<p>    移动方面<br />        保证组件小于 25k<br />        Pack Components into a Multipart Document<br />		<br />9.什么是渐进增强<br />渐进增强是指在 web 设计时强调可访问性、语义化 HTML 标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能同时为高级浏览器和高带宽用户提供更好的用户体验。核心原则如下:</p>
<p>    所有浏览器都必须能访问基本内容<br />    所有浏览器都必须能使用基本功能<br />    所有内容都包含在语义化标签中<br />    通过外部 CSS 提供增强的布局<br />    通过非侵入式、外部 javascript 提供增强功能</p>
<p>10.web开发中会话跟踪的方法有哪些<br />	cookie<br />	session<br />	url重写<br />	隐藏input<br />	ip地址</p>
<p>11.doctype是什么,举例常见doctype及特点<br />&lt;!doctype&gt;声明必须处于HTML文档的头部，在&lt;html&gt;标签之前，HTML5中不区分大小写<br />&lt;!doctype&gt;声明不是一个HTML标签，是一个用于告诉浏览器当前HTMl版本的指令<br />现代浏览器的html布局引擎通过检查doctype决定使用兼容模式还是标准模式对文档进行渲染，一些浏览器有一个接近标准模型。<br />在HTML4.01中&lt;!doctype&gt;声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容<br />HTML5不基于SGML，所以不用指定DTD</p>
<p>12.如何进行网站性能优化<br />content方面：<br />减少HTTP请求：合并文件、CSS精灵、inline Image<br />减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询<br />避免重定向：多余的中间访问<br />使Ajax可缓存<br />非必须组件延迟加载<br />未来所需组件预加载<br />减少DOM元素数量<br />将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量<br />减少iframe数量<br />不要404</p>
<p>Server方面：<br />使用CDN<br />添加Expires或者Cache-Control响应头<br />对组件使用Gzip压缩<br />配置ETag<br />Flush Buffer Early<br />Ajax使用GET进行请求<br />避免空src的img标签</p>
<p>Cookie方面：<br />减小cookie大小<br />引入资源的域名不要包含cookie</p>
<p>css方面：<br />将样式表放到页面顶部<br />不使用CSS表达式<br />不使用@import<br />不使用IE的Filter</p>
<p>Javascript方面：<br />将脚本放到页面底部<br />将javascript和css从外部引入<br />压缩javascript和css<br />删除不需要的脚本<br />减少DOM访问<br />合理设计事件监听器</p>
<p>图片方面：<br />优化图片：根据实际颜色需要选择色深、压缩<br />优化css精灵<br />不要在HTML中拉伸图片<br />保证favicon.ico小并且可缓存</p>
<p>移动方面：<br />保证组件小于25k<br />Pack Components into a Multipart Documentary</p>
<p>13.HTTP状态码及其含义<br />1XX：信息状态码<br />2XX：成功状态码<br />	200 OK：请求成功，请求所希望的响应头或数据体将随此响应返回<br />3XX：重定向<br />4XX：客户端错误<br />	400 Bad Request:<br />	401 Unauthorized:<br />	402 Payment Required:<br />	403 Forbidden:<br />	404 Not Found:<br />5XX: 服务器错误<br />	500 Internal Server Error:</p>
<p>14.css sprite是什么,有什么优缺点<br />概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。<br />优点：<br />减少HTTP请求数，极大地提高页面加载速度<br />增加图片信息重复度，提高压缩比，减少图片大小<br />更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现<br />缺点：<br />图片合并麻烦<br />维护麻烦，修改一个图片可能需要从新布局整个图片，样式</p>
<p>15.display: none;与visibility: hidden;的区别<br />联系：它们都能让元素不可见<br />区别：<br />display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见<br />display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式<br />修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。<br />读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容</p>
<p>16.css hack原理及常用hack<br />原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。常见的hack有1）属性hack。2）选择器hack。3）IE条件注释</p>
<p>17.link与@import的区别<br />link是HTML方式， @import是CSS方式<br />link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC<br />link可以通过rel="alternate stylesheet"指定候选样式<br />浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式<br />@import必须在样式规则之前，可以在css文件中引用其他文件<br />总体来说：link优于@important</p>
<p>18.PNG,GIF,JPG的区别及如何选择正确的图片格式<br />GIF:<br />8位像素，256色<br />无损压缩<br />支持简单动画<br />支持boolean透明<br />适合简单动画<br />JPEG：<br />颜色限于256<br />有损压缩<br />可控制压缩质量<br />不支持透明<br />适合照片<br />PNG：<br />有PNG8和truecolor PNG<br />PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画<br />适合图标、背景、按钮</p>
<p>19.什么是FOUC?如何避免<br />Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。解决方法：把样式表放到文档的head</p>
<p>20.sessionStorage,localStorage,cookie区别<br />都会在浏览器端保存，有大小限制，同源限制<br />cookie会在请求时发送到服务器，作为会话标识，服务器可修改cookie；web storage不会发送到服务器<br />cookie有path概念，子路径可以访问父路径cookie，父路径不能访问子路径cookie<br />有效期：cookie在设置的有效期内有效，默认为浏览器关闭；sessionStorage在窗口关闭前有效，localStorage长期有效，直到用户删除<br />共享：sessionStorage不能共享，localStorage在同源文档之间共享，cookie在同源且符合path规则的文档之间共享<br />localStorage的修改会促发其他文档窗口的update事件<br />cookie有secure属性要求HTTPS传输<br />浏览器不能保存超过300个cookie，单个服务器不能超过20个，每个cookie不能超过4k。web storage大小支持能达到5M</p>
<p>20.javascript跨域通信<br />同源：两个文档同源需满足<br />协议相同<br />域名相同<br />端口相同<br />跨域通信：js进行DOM操作、通信时如果目标与当前窗口不满足同源条件，浏览器为了安全会阻止跨域操作。跨域通信通常有以下方法<br />如果是log之类的简单单项通信，新建&lt;img&gt;,&lt;script&gt;,&lt;link&gt;,&lt;iframe&gt;元素，通过src，href属性设置为目标url。实现跨域请求<br />如果请求json数据，使用&lt;script&gt;进行jsonp请求<br />现代浏览器中多窗口通信使用HTML5规范的targetWindow.postMessage(data, origin);其中data是需要发送的对象，origin是目标窗口的origin。window.addEventListener('message', handler, false);handler的event.data是postMessage发送来的数据，event.origin是发送窗口的origin，event.source是发送消息的窗口引用<br />内部服务器代理请求跨域url，然后返回数据<br />跨域请求数据，现代浏览器可使用HTML5规范的CORS功能，只要目标服务器返回HTTP头部Access-Control-Allow-Origin: *即可像普通ajax一样访问跨域资源</p>
<p>21.javascript有哪几种数据类型<br />六种基本数据类型</p>
<p>undefined<br />null<br />string<br />boolean<br />number<br />symbol(ES6)<br />一种引用类型</p>
<p>Object</p>
<p>22.什么闭包,闭包有什么用<br />闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。闭包作用域链通常包括三个部分：</p>
<p>函数本身作用域。<br />闭包定义时的作用域。<br />全局作用域。<br />闭包常见用途：</p>
<p>创建特权方法用于访问控制<br />事件处理程序及回调</p>
<p><br />		</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>