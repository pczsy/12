<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修【前端知识体系-JS相关】JS-Web-API总结' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>【前端知识体系-JS相关】JS-Web-API总结</center></div><div class='banquan'>原文出处:本文由博客园博主Web前端社区提供。<br/>
原文连接:https://www.cnblogs.com/fecommunity/p/11908767.html</div><br>
    <h2 id="dom操作">2.1 DOM操作</h2>
<h3 id="dom的本质是什么">2.1.1 DOM的本质是什么？</h3>
<pre><code><code>&lt;!-- DOM树：二叉树 --&gt;
    /*
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&gt;               // 告诉浏览器以哪一种类型进行解析
    &lt;node&gt;
        &lt;child /&gt;
    &lt;/node&gt;
     */

    &lt;!DOCTYPE html&gt;                                      // 以html类型进行解析文档内容
    &lt;html&gt;
        &lt;body&gt;

        &lt;/body&gt;
    &lt;/html&gt;</code></pre>
<h3 id="dom操作的常用api有哪些">2.1.2 DOM操作的常用API有哪些？</h3>
<h4 id="节点查找api">节点查找API</h4>
<ol>
<li><strong>document.getElementById</strong> ：根据ID查找元素，大小写敏感，如果有多个结果，只返回第一个；</li>
<li><strong>document.getElementsByClassName</strong> ：根据类名查找元素，多个类名用空格分隔，返回一个 HTMLCollection 。注意兼容性为IE9+（含）。另外，不仅仅是document，其它元素也支持 getElementsByClassName 方法；</li>
<li><strong>document.getElementsByTagName</strong> ：根据标签查找元素， * 表示查询所有标签，返回一个 HTMLCollection 。</li>
<li><strong>document.getElementsByName</strong> ：根据元素的name属性查找，返回一个 NodeList 。</li>
<li><strong>document.querySelector</strong> ：返回单个Node，IE8+(含），如果匹配到多个结果，只返回第一个。</li>
<li><strong>document.querySelectorAll</strong> ：返回一个 NodeList ，IE8+(含）。</li>
<li><strong>document.forms</strong> ：获取当前页面所有form，返回一个 HTMLCollection ；</li>
</ol>
<h4 id="节点创建api">节点创建API</h4>
<ol>
<li><strong>createElement</strong>创建元素</li>
<li><strong>createTextNode</strong>创建文本节点</li>
<li><strong>cloneNode</strong> 克隆一个节点</li>
<li><strong>createDocumentFragment</strong></li>
</ol>
<h4 id="节点修改api">节点修改API</h4>
<ol>
<li><strong>appendChild</strong></li>
<li><strong>insertBefore</strong></li>
<li><strong>insertAdjacentHTML</strong></li>
<li><strong>Element.insertAdjacentElement()</strong></li>
<li><strong>removeChild</strong></li>
<li><strong>replaceChild</strong></li>
</ol>
<h4 id="节点关系api">节点关系API</h4>
<ul>
<li>1、父关系API</li>
</ul>
<p><strong>parentNode</strong> ：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment；<br />
<strong>parentElement</strong> ：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element元素，如果不是，则返回null；</p>
<ul>
<li>2、子关系API</li>
</ul>
<p><strong>children</strong> ：返回一个实时的 HTMLCollection ，子节点都是Element，IE9以下浏览器不支持；</p>
<p><strong>childNodes</strong> ：返回一个实时的 NodeList ，表示元素的子节点列表，注意子节点可能包含文本节点、注释节点等；</p>
<p><strong>firstChild</strong> ：返回第一个子节点，不存在返回null，与之相对应的还有一个 firstElementChild ；</p>
<p><strong>lastChild</strong> ：返回最后一个子节点，不存在返回null，与之相对应的还有一个 lastElementChild ；</p>
<ul>
<li>3、兄弟关系型API</li>
</ul>
<p><strong>previousSibling</strong> ：节点的前一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。</p>
<p><strong>nextSibling</strong> ：节点的后一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。</p>
<p><strong>previousElementSibling</strong> ：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。</p>
<p><strong>nextElementSibling</strong> ：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。</p>
<h4 id="元素属性型api">元素属性型API</h4>
<p>1、<strong>setAttribute</strong> 给元素设置属性：<br />
2、<strong>getAttribute</strong><br />
3、<strong>hasAttribute</strong></p>
<h4 id="样式操作api面试考点">样式操作API（面试考点）</h4>
<ul>
<li>1、直接修改元素的样式</li>
</ul>
<pre class="js"><code>elem.style.color = &#39;red&#39;;  
elem.style.setProperty(&#39;font-size&#39;, &#39;16px&#39;);  
elem.style.removeProperty(&#39;color&#39;);  </code></pre>
<ul>
<li>2、动态添加样式规则</li>
</ul>
<pre class="js"><code>var style = document.createElement(&#39;style&#39;);  
style.innerHTML = &#39;body{color:red} #top:hover{background-color: red;color: white;}&#39;;  
document.head.appendChild(style);  </code></pre>
<ul>
<li><p>3、classList获取样式属性</p>
<blockquote>
<p>[!NOTE]<br />
了解dom节点样式(classList)的remove, add, toggle, contains, replace等方法的使用。</p>
</blockquote></li>
<li><p>4、window.getComputedStyle<br />
通过 <strong>element.sytle.xxx</strong> 只能获取到内联样式，借助 <strong>window.getComputedStyle</strong> 可以获取应用到元素上的所有样式，IE8或更低版本不支持此方法。</p></li>
</ul>
<pre class="js"><code>var style = window.getComputedStyle(element[, pseudoElt]);  </code></pre>
<h3 id="dom节点的attr和proerty的区别">2.1.3 DOM节点的attr和proerty的区别</h3>
<pre class="js"><code>// proprty------&gt;&gt;&gt;获取nodeName和nodeType（property实际上就是JS对象的一个属性）如：text : 3(#text), p : 1(p)
    console.log(pList[0].nodeName);         // p
    console.log(pList[0].nodeType);         // 1
// attribute------&gt;&gt;&gt; 获取一个HTML标签的属性信息（设置和修改）
    var a = document.getElementsByTagName(&#39;a&#39;)[0];
    console.log(a.getAttribute(&#39;data-origin&#39;));
    console.log(a.getAttribute(&quot;href_name&quot;));           // 可以给一个HTML标签设置任意的属性名称，无论这个属性内部是否存在
a.  setAttribute(&#39;sex&#39;, &#39;male&#39;)
// 区别：
// (JS对象&amp;HTML标签)property实际上是一个普通JS对象本身的基本属性，但是attribute实际上是一个HTML标签上面的属性信息</code></pre>
<blockquote>
<p>[!NOTE]<br />
区别：(JS对象&amp;HTML标签)property实际上是一个普通JS对象本身的基本属性，但是attribute实际上是一个HTML标签上面的属性信息</p>
</blockquote>
<h2 id="bom操作">2.2 BOM操作</h2>
<h3 id="如何检测浏览器的类型">2.2.1 如何检测浏览器的类型？</h3>
<pre class="js"><code>var ua = navigator.userAgent;
    var isChrome = ua.indexOf(&#39;Chrome&#39;);
    console.log(&#39;is Chrome?&#39;, isChrome &gt; 0, navigator.userAgent);
    console.log(&#39;电脑屏幕大小：&#39;, screen.width, screen.height)
</code></pre>
<h3 id="如何拆解url的各个部分">2.2.2 如何拆解URL的各个部分？</h3>
<pre class="js"><code>// location
    console.log(location.href);                 // 完整的url地址，http://localhost:8080/JS-Professional/begin/02-%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/01-%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E8%BF%9B%E9%98%B6.html?_ijt=i8ctmkc87dvh03tdaf51rn5v1i
    console.log(location.protocol)              // http/https
    console.log(location.host, location.hostname)                  // www.52tech.tech
    console.log(location.pathname);             // host之后的全部内容，JS-Professional/begin/02-%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/01-%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E8%BF%9B%E9%98%B6.html
    console.log(location.search);               // search就是？之后的全部内容，?_ijt=i8ctmkc87dvh03tdaf51rn5v1i（包括？）
    console.log(location.hash);                 // #后面的内容（包括#）
</code></pre>
<h2 id="事件操作">2.3 事件操作</h2>
<h3 id="编写一个通用的事件监听函数">2.3.1 编写一个通用的事件监听函数</h3>
<pre class="js"><code>    function bindEvent(ele, type, selector, fn){
        if (fn == null) {
            fn = selector;
            selector = null;
        }

        // addEventListener 的最后一个参数默认是false, 表示的是事件冒泡，自下向上去捕获事件，true：表示事件捕获，表示事件自外向里的方式
        ele.addEventListener(type, function(e){
            if (selector) {
                // 使用的是代理的方式的话
                if (e.target.matches(selector)){            // 这里需要去判断当前点击的那个对象是不是我点击的那个对象
                    fn.call(e.target, e);
                }
            } else {
                // 不使用代理的话
                fn(e);
            }
        });
    }


    // 这里表示对这个div1 内部的所有的a标签使用事件冒泡
    bindEvent(document.getElementById(&#39;div4&#39;), &#39;click&#39;, &#39;p&#39;, function (e) {
        console.log(this.innerHTML + &#39;hahaah&#39;)
    })
版本2：
/**
     * 实现一个通用的事件绑定函数（代码简洁，减少了浏览器的占用）
     * @param element
     * @param type
     * @param selector
     * @param fn
     */
    function bindEvent(element, type, selector, fn) {
        // if (fn === null || fn === undefined)        // 这里可以直接优化为fn == null
        if (fn == null){
            // 只有3个参数的话
            fn = selector;
            selector = null;
        }

        element.addEventListener(type, function (e) {
            var target;
            // 如果selector有的话，说明此事element就是一个代理
            if (selector) {
                target = e.target;
                // 如果当前的target满足这个选择器的话
                // 如果元素被指定的选择器字符串选择，Element.matches()  方法返回true; 否则返回false。
                // document.getElementById(&#39;div1&#39;).matches(&#39;div&#39;)    true
                // matches里面的参数实际上是一个HTML标签：a, p, div …………， 内容也是不区分大小写的，有点类似于nodeName 或者nodeType 这样的判断
                if (target.matches(selector)){
                    // 修改this的指向
                    fn.call(target, e);
                }
            }else {
                fn(e);
            }
        });
    }
</code></pre>
<h3 id="描述事件冒泡的流程">2.3.2 描述事件冒泡的流程</h3>
<blockquote>
<p>[!NOTE]<br />
&quot;DOM2级事件”规定的事件流包含三个阶段：事件捕获阶段，处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，然后是实际的目标接收到事件，最后阶段是冒泡阶段。</p>
<ul>
<li>事件冒泡：<br />
按照DOM树形结构向上冒泡(p --- &gt;&gt;&gt; div --- &gt;&gt;&gt; body --- &gt;&gt;&gt; document),</li>
<li>事件捕获<br />
（document—&gt;<html>—&gt;<body>—&gt;<div>的顺序进行传播的）</li>
</ul>
</blockquote>
<h3 id="对于一个无线下拉图片的页面如何给每一个图片绑定一个事件">2.3.3 对于一个无线下拉图片的页面，如何给每一个图片绑定一个事件</h3>
<pre class="js"><code>// 代理（div3里面的所有a标签都需要进行事件的监听）
    var div3 = document.getElementById(&#39;div3&#39;);
    bindEvent(div3, &#39;click&#39;, function (e) {
        e.preventDefault();
        e.stopPropagation()
        // 可以获取真实触发的那个元素
        var target = e.target;
        console.log(target.nodeName, target.nodeType);      // 每一种页面标签实际上都有一个自己专属的nodeName
        // 这里的目的主要是用于过滤，只处理a标签的事件处理
        if (&#39;A&#39; === target.nodeName) {
            //  如果当前点击的a标签就是自己
            alert(target.innerHTML)
        }
    })
</code></pre>
<h2 id="ajax操作">2.4 Ajax操作</h2>
<h3 id="手动编写一个ajax不依赖第三方库">2.4.1 手动编写一个ajax，不依赖第三方库</h3>
<h3 id="跨域的几种实现方式以及底层的实现原理">2.4.2 跨域的几种实现方式以及底层的实现原理</h3>
<ol>
<li>服务器端的使用：response.setHeader(Access-Control-Allow-Origin, &quot;http://www.baidu.com, http://www.52tech.tech&quot;)允许跨域</li>
<li>使用JSONP</li>
</ol>
<h3 id="jsonp的实现原理">2.4.3 JSONP的实现原理</h3>
<blockquote>
<p>[!NOTE]<br />
跨域：浏览器有同源策略，不允许ajax访问其他域接口</p>
<ul>
<li>跨域条件：协议、域名、端口，有一个不同就是跨域</li>
</ul>
</blockquote>
<p>可以跨域加载资源的3个标签：</p>
<pre><code><code>&lt;img src=&quot;&quot;&gt;, &lt;link href=&quot;&quot;&gt;, &lt;script src=&quot;&quot;&gt;</code></pre>
<ul>
<li>img用途：主要用于打点统计，统计网站可能是其他域</li>
<li>link, script用途：可以使用CDN，可以使用其他域</li>
<li>script用途：可以用于JSONP</li>
</ul>
<h4 id="跨域注意事项">2.4.3.1 跨域注意事项:</h4>
<ol>
<li>所有的跨域请求都必须经过信息提供方的允许才可以获取</li>
<li>如果未经允许就可以直接获取，就是浏览器的同源策略出现漏洞</li>
</ol>
<h4 id="浏览器端实现提前定义一个回调函数">2.4.3.2 浏览器端实现（提前定义一个回调函数）</h4>
<pre class="js"><code>//封装一个jsonp请求的函数
  function query(opt) {
      let str = &quot;&quot;
      for (let key in opt) {
          str += key + &quot;=&quot; + opt[key] + &quot;&amp;&quot;
      }
      return str
  }
  //设置默认回调函数的名字
  const defaultOptions = {
      callbackName: &quot;callback&quot;
  }
  function jsonp(url, opt, options = defaultOptions) {
      //参数解析  URL为访问的接口 opt为传播的数据  option 为接受参数的回调函数
      return new Promise((resolve, reject) =&gt; {
          //判断下这个？是不是存在
          let index = url.indexOf(&quot;?&quot;);
          url += index != -1 ? query(opt) : &quot;?&quot; + query(opt);
          url = url + `${options.callbackName}=${options.callbackName}`;
          //首先创造一个标签 带有src的
          const scriptDom = document.createElement(&quot;script&quot;);
          //设置其src属性
          scriptDom.setAttribute(&quot;src&quot;, url);
          //在window系统上创建一个回调函数用来接受数据
          window[options.callbackName] = (res) =&gt; {
              //在接受到了参数动态删除这个script节点和window上面的方法
              delete window[options.callbackName];
              document.body.removeChild(scriptDom)
              //接受成功后调用resolve
              if (res) {
                  resolve(res)
              } else {
                  reject(&quot;服务器暂没有获取到数据&quot;)
              }
          }
          //动态创建script标记，错误的监听
          scriptDom.addEventListener(&#39;error&#39;, () =&gt; {
              delete window[&#39;jsonpCallback&#39;];
              document.body.removeChild(script);
              reject(&#39;服务器加载失败！&#39;);
          });
          document.body.append(scriptDom)
      })
  }</code></pre>
<h4 id="后端实现">2.4.3.3 后端实现</h4>
<pre class="js"><code>const url = require(&quot;url&quot;)

router.get(&quot;/api&quot;, (req, res, next) =&gt; {
  //将script标签的src的URL请求转成对象
  const opj = url.parse(req.url, true).query;
  //然后原理就是调用这个回调函数来进行传参
  let {
    callback
  } = opj;
  //如果这个回调函数存在证明是jsonp请求
  if (callback) {
    let resault = JSON.stringify({
      code: 1,
      msg: &quot;express框架传回去的参数&quot;
    });
    res.send(`${callback}(${resault})`)
  }
})</code></pre>
<h2 id="本地存储">2.5 本地存储</h2>
<h3 id="cookie-sessionstorage-localstorage-的区别">2.5.1 cookie, sessionStorage, localStorage 的区别</h3>
<h4 id="cookie">Cookie</h4>
<ol>
<li>存储量，只有4kb</li>
<li>所有的http请求都会带有cookie，会直接影响获取资源效率</li>
<li>API，document.cookie</li>
</ol>
<h4 id="localstorage">localstorage</h4>
<ol>
<li>localstorage.setItem(key, value);localstorage.getItem('key');</li>
<li>存储量5MB</li>
<li><p>sessionStorage：会话级别</p>
<blockquote>
<p>[!WARNING]<br />
【坑】IOS safari的隐藏模式下，使用localStorage.getItem('key') 会报错，建议使用try{}catch(e){} 来实现可以防止报错</p>
</blockquote></li>
</ol>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>