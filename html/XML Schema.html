<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修XML Schema' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>XML Schema</center></div><div class='banquan'>原文出处:本文由博客园博主功夫 熊猫提供。<br/>
原文连接:https://www.cnblogs.com/kungfupanda/p/11645560.html</div><br>
    <h1 id="firstHeading" class="firstHeading" lang="zh-Hans-CN">XML Schema<span class="mw-editsection"><span class="mw-editsection-bracket"><span class="mw-editsection-bracket"><br /></span></span></span></h1>
<div id="bodyContent" class="mw-body-content">
<div id="siteSub" class="noprint"><strong><br />XSD (XML Schema Definition)</strong>是<a class="mw-redirect" title="World Wide Web Consortium" href="https://zh.wikipedia.org/wiki/World_Wide_Web_Consortium">W3C</a>于2001年5月发布的推荐标准，指出如何形式描述XML文档的元素。XSD是许多<a title="XML Schema 语言" href="https://zh.wikipedia.org/wiki/XML_Schema_%E8%AF%AD%E8%A8%80">XML Schema 语言</a>中的一支。XSD是首先分离于XML本身的schema语言，故获取W3C的推荐地位。</div>
<div id="mw-content-text" class="mw-content-ltr" lang="zh-Hans-CN" dir="ltr">
<div class="mw-parser-output">
<p>像所有<a title="XML Schema 语言" href="https://zh.wikipedia.org/wiki/XML_Schema_%E8%AF%AD%E8%A8%80">XML Schema 语言</a>一样，XSD用来描述一组规则──一个XML文件必须遵守这些规则，才能根据该schema&lsquo;合法（Valid）&rsquo;。</p>
<p>然而，与其他<a title="XML Schema 语言" href="https://zh.wikipedia.org/wiki/XML_Schema_%E8%AF%AD%E8%A8%80">XML Schema 语言</a>不同，XSD意图设计为在确认一个文档的有效性时，将会产生满足特定<a class="mw-redirect" title="数据类型" href="https://zh.wikipedia.org/wiki/%E6%95%B8%E6%93%9A%E9%A1%9E%E5%9E%8B">数据类型</a>的一个信息集合。这种后验证的<a title="XML信息集" href="https://zh.wikipedia.org/wiki/XML%E4%BF%A1%E6%81%AF%E9%9B%86">XML信息集</a>可用来开发XML文件处理软件。</p>
<div id="toc" class="toc">
<div class="toctitle" lang="zh-Hans-CN" dir="ltr">
<h2>目录</h2>
</div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="https://zh.wikipedia.org/wiki/XML_Schema#XSD%E5%90%8D%E7%A7%B0%E7%9A%84%E6%9D%A5%E6%BA%90"><span class="tocnumber">1<span class="toctext">XSD名称的来源</span></span></a></li>
<li class="toclevel-1 tocsection-2"><a href="https://zh.wikipedia.org/wiki/XML_Schema#%E6%AD%B7%E5%8F%B2"><span class="tocnumber">2<span class="toctext">历史</span></span></a></li>
<li class="toclevel-1 tocsection-3"><a href="https://zh.wikipedia.org/wiki/XML_Schema#Schema%E4%B8%8Eschema%E6%96%87%E6%A1%A3"><span class="tocnumber">3<span class="toctext">Schema与schema文档</span></span></a></li>
<li class="toclevel-1 tocsection-4"><a href="https://zh.wikipedia.org/wiki/XML_Schema#Schema_component"><span class="tocnumber">4<span class="toctext">Schema component</span></span></a></li>
<li class="toclevel-1 tocsection-5"><a href="https://zh.wikipedia.org/wiki/XML_Schema#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="tocnumber">5<span class="toctext">数据类型</span></span></a></li>
<li class="toclevel-1 tocsection-6"><a href="https://zh.wikipedia.org/wiki/XML_Schema#Schema_%E6%97%A2%E9%AA%8C%E4%BF%A1%E6%81%AF%E9%9B%86%EF%BC%88Post-Schema-Validation_Infoset%EF%BC%89"><span class="tocnumber">6<span class="toctext">Schema 既验信息集（Post-Schema-Validation Infoset）</span></span></a></li>
<li class="toclevel-1 tocsection-7"><a href="https://zh.wikipedia.org/wiki/XML_Schema#XML_Schema%E7%9A%84%E6%AC%A1%E8%A6%81%E7%94%A8%E9%80%94"><span class="tocnumber">7<span class="toctext">XML Schema的次要用途</span></span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="https://zh.wikipedia.org/wiki/XML_Schema#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="tocnumber">7.1<span class="toctext">代码生成</span></span></a></li>
<li class="toclevel-2 tocsection-9"><a href="https://zh.wikipedia.org/wiki/XML_Schema#XML%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%96%87%E6%A1%A3%E7%9A%84%E7%94%9F%E6%88%90"><span class="tocnumber">7.2<span class="toctext">XML文件结构文档的生成</span></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="https://zh.wikipedia.org/wiki/XML_Schema#%E6%89%B9%E8%AF%84"><span class="tocnumber">8<span class="toctext">批评</span></span></a></li>
<li class="toclevel-1 tocsection-11"><a href="https://zh.wikipedia.org/wiki/XML_Schema#%E7%A4%BA%E8%8C%83"><span class="tocnumber">9<span class="toctext">示范</span></span></a></li>
<li class="toclevel-1 tocsection-12"><a href="https://zh.wikipedia.org/wiki/XML_Schema#%E5%8F%83%E8%A6%8B"><span class="tocnumber">10<span class="toctext">参见</span></span></a></li>
<li class="toclevel-1 tocsection-13"><a href="https://zh.wikipedia.org/wiki/XML_Schema#%E5%A4%96%E9%83%A8%E9%80%A3%E7%B5%90"><span class="tocnumber">11<span class="toctext">外部链接</span></span></a></li>
</ul>
</div>
<h2><span id="XSD.E5.90.8D.E7.A7.B0.E7.9A.84.E6.9D.A5.E6.BA.90"><span id="XSD名称的来源" class="mw-headline">XSD名称的来源<span class="mw-editsection"><span class="mw-editsection-bracket"><span class="mw-editsection-bracket"><br /></span></span></span></span></span></h2>
<p>因为有其他XML schema 语言存在，故在引用这W3C建议的语言时，使用XML Schema或W3C XML Schema，Schema永远前缀大写。</p>
<p>&ldquo;XML Schema&rdquo;在2001年5月成为W3C推荐标准。由于&ldquo;XML Schema&rdquo;作为一种W3C的推荐标准的名字与广义的<a title="XML Schema 语言" href="https://zh.wikipedia.org/wiki/XML_Schema_%E8%AF%AD%E8%A8%80">XML Schema 语言</a>存在名称上的混淆，用户社区的一部分人采用了&ldquo;WXS&rdquo;来称呼它， 用户社区的另一部分人采用&ldquo;<strong>XSD</strong>&rdquo;（<strong>X</strong>ML&nbsp;<strong>S</strong>chema&nbsp;<strong>D</strong>efinition<a title="首字母缩略字" href="https://zh.wikipedia.org/wiki/%E9%A6%96%E5%AD%97%E6%AF%8D%E7%B8%AE%E7%95%A5%E5%AD%97">首字母缩略字</a>）来称呼它。W3C发布的1.1标准采用了&ldquo;<strong>XSD</strong>&rdquo;作为官方称呼。</p>
<h2><span id=".E6.AD.B7.E5.8F.B2"><span id="歷史" class="mw-headline">历史</span></span></h2>
<p>在官方文档的参考附录里，XSD标准承认受到[文件类型描述|DTD]]和其他早期XML schema 语言的影响，如<span class="ilh-all" data-orig-title="DDML" data-lang-code="en" data-lang-name="英语" data-foreign-title="DDML"><span class="ilh-page"><a class="new" href="https://zh.wikipedia.org/w/index.php?title=DDML&amp;action=edit&amp;redlink=1">DDML</a>、<span class="ilh-all" data-orig-title="Schema for Object-Oriented XML" data-lang-code="en" data-lang-name="英语" data-foreign-title="Schema for Object-Oriented XML"><span class="ilh-page"><a class="new" href="https://zh.wikipedia.org/w/index.php?title=Schema_for_Object-Oriented_XML&amp;action=edit&amp;redlink=1">SOX</a>、<span class="ilh-all" data-orig-title="XML-Data" data-lang-code="en" data-lang-name="英语" data-foreign-title="XML-Data"><span class="ilh-page"><a class="new" href="https://zh.wikipedia.org/w/index.php?title=XML-Data&amp;action=edit&amp;redlink=1">XML-Data</a>、以及<span class="ilh-all" data-orig-title="XML data reduced" data-lang-code="en" data-lang-name="英语" data-foreign-title="XML data reduced"><span class="ilh-page"><a class="new" href="https://zh.wikipedia.org/w/index.php?title=XML_data_reduced&amp;action=edit&amp;redlink=1">XDR</a>。XSD从中吸收了一些特性，然而也在这些特性中有所折衷。这些早期schema 语言中的XDR与SOX在XML Schema发布后仍继续使用了一段时间。不少<a class="mw-redirect" title="微软" href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E8%BB%9F">微软</a>的产品支持XDR直到2006年十二月<a title="MSXML" href="https://zh.wikipedia.org/wiki/MSXML">MSXML</a>&nbsp;6.0的发布（MSXML 6.0抛弃了XDR改用XSD）<a class="external autonumber" href="http://msdn.microsoft.com/en-us/library/ms761410" rel="nofollow">[1]</a>&nbsp;。<span lang="en">Commerce One, Inc支持它自己的SOX schema 语言直到该公司于2004年末破产。2004年十二月，<a title="Novell" href="https://zh.wikipedia.org/wiki/Novell">Novell, Inc.</a>购买了该公司，包括那些与SOX相关的专利，据报导是尽力防止被某些不相关的、以打专利相关官司为生的公司剥削图利<a class="external autonumber" href="http://www.iht.com/articles/2005/05/02/business/novell.php" rel="nofollow">[2]</a>&nbsp;。</span></span></span></span></span></span></span></span></span></p>
<p>著名的XSD建议的内容但在XML自己的DTD中不可用的特性是名字空间感知（namespace awareness）与数据类型。</p>
<p>2012年4月， XSD 1.1成为W3C推荐标准。<a class="external text" href="http://www.w3.org/News/2012#entry-9412" rel="nofollow">April 2012</a></p>
<h2><span id="Schema.E4.B8.8Eschema.E6.96.87.E6.A1.A3"><span id="Schema与schema文档" class="mw-headline">Schema与schema文档</span></span></h2>
<p>技术上说<strong>schema</strong>是元数据的一个抽象集合，包含一套<strong>schema component</strong>: 主要是元素与属性的声明、复杂与简单数据类型的定义。这些schema component通常是在处理一批<strong>schema document</strong>时被创建。schema文档包含着schema component的源语言定义。在日常使用中，一个schema文档常被称作一个schema。</p>
<p>Schema文档通过名字空间组织起来：所有的被命名的schema component属于一个目标名字空间；这个目标名字空间是schema文档作为整体的一个属性。schema文档可以包含进来（include）使用同一名字空间的其它schema文档，也可以导入（import）使用不同名字空间的schema文档。</p>
<p>当一个实例文档针对一个schema来验证有效性时（这一过程称为<em>assessment</em>），用来验证有效性的schema可以作为参数提供给验证器，也可以在实例文档中作为两种特殊属性之一直接提供：</p>
<ul>
<li><code>xsi:schemaLocation</code></li>
<li><code>xsi:noNamespaceSchemaLocation</code>.这种机制要求客户启动验证以充分相信这个文档，知道文档对正确的schema是有效的。</li>
</ul>
<p>"xsi"是名字空间"<a class="external free" href="http://www.w3.org/2001/XMLSchema-instance" rel="nofollow">http://www.w3.org/2001/XMLSchema-instance</a>"的传统前缀。</p>
<p>XML Schema Documents通常有<a title="文件扩展名" href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D">文件扩展名</a>".xsd". XSD还没有专门的<a title="互联网媒体类型" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B">互联网媒体类型</a>，因此按照 RFC 3023使用"application/xml"或"text/xml" .</p>
<h2><span id="Schema_component" class="mw-headline">Schema component</span></h2>
<p>主要的schema component有:</p>
<ul>
<li><strong>元素声明</strong>（Element declaration）, 定义了元素的性质。包括：元素名字、目标名字空间；一个非常重要的性质是元素的类型，它限制了元素包含哪些属性与子元素。在XSD 1.1标准中，可以根据属性的值来有条件定义元素类型。一个元素可以属于一个替换群（substitution group），如果元素E在元素H的替换群中，那么schema许可H出现的地方E都可以出现。元素可以有完整性（integrity）约束：唯一性（uniqueness）约束确定特定值在该元素为根的子树中是独一无二的；引用（referential）约束确定值必须匹配一些其它元素的标识符。元素声明可以是全局的或局部的，允许同一个名字被用于一个实例文档的不同部分的不相关的元素。</li>
<li><strong>属性声明</strong>（Attribute declaration）,定义了属性的性质。包括：属性名字、目标名字空间，属性类型限制了属性可以取哪些值，也可以指出属性的缺省值或固定值（fixed value，即属性只能取这个值）。</li>
<li><strong>简单与复杂数据类型</strong>（Simple and complex type）.详见下节</li>
<li><strong>模型群</strong>（model group）与<strong>属性群</strong>（attribute group）定义。这实际上是宏（macro）：被命名的元素的群与属性的群，可在许多数据类型定义中被重用。</li>
<li><strong>属性使用</strong>（attribute use）表示复杂数据类型与属性声明的关系，指出属性是必需的还是可选的，在什么时候使用这种数据类型。</li>
<li><strong>元素粒子</strong>（element particle）类似于表示复杂类型与元素的关系，指出元素在上下文中出现的最大与最小次数。类似于元素粒子，内容模型可以包括<strong>模型群粒子</strong>，在语法上相当于非终结符：定义了允许的元素序列的选择与重复的单位。此外，<strong>通配符粒子</strong>表示了一套元素或元素序列。</li>
</ul>
<p>其它更专门的schema component包括annotations, assertions, notations, 以及包含了schema整体信息的<strong>schema component</strong>.</p>
<h2><span id=".E6.95.B0.E6.8D.AE.E7.B1.BB.E5.9E.8B"><span id="数据类型" class="mw-headline">数据类型</span></span></h2>
<p>简单数据类型（simple type）包含了可以出现在元素或属性的文本值。这是XSD与DTD的最大区别。</p>
<p>XSD提供了一套19个基本数据类型：</p>
<ul>
<li><code>anyURI</code></li>
<li><code>base64Binary</code></li>
<li><code>boolean</code></li>
<li><code>date</code></li>
<li><code>dateTime</code></li>
<li><code>decimal</code></li>
<li><code>double</code></li>
<li><code>duration</code></li>
<li><code>float</code></li>
<li><code>hexBinary</code></li>
<li><code>gDay</code></li>
<li><code>gMonth</code></li>
<li><code>gMonthDay</code></li>
<li><code>gYear</code></li>
<li><code>gYearMonth</code></li>
<li><code>NOTATION</code></li>
<li><code>QName</code></li>
<li><code>string</code></li>
<li><code>time</code>).</li>
</ul>
<p>可以从这些基本数据类型通过三种机制构建三种数据类型：</p>
<ul>
<li>restriction (减少值集的范围),</li>
<li>list (允许一个值的序列),</li>
<li>union (允许从几个数据类型中选择值).</li>
</ul>
<p>XSD规范定义了25个导出数据类型。用户可以在schema中进一步定义自己的导出类型。</p>
<p>Restriction机制包括指出最大最小值、<a title="正则表达式" href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a>、限制字符串的长度、限制十进制数的位数等。XSD 1.1又增加了assertions, 即通过一个[XPath 2.0]]表达式给出任意约束的能力。</p>
<p>复杂数据类型描述了一个元素的许可内容。包括这个元素、属性、子元素的许可内容。复杂类型定义由一套属性使用与一个内容模型组成。内容模型可以是：</p>
<ul>
<li>只有元素的内容（element-only content）, 不允许有文本（但可以有空白符或者子元素可以有文本）;</li>
<li>简单内容（simple content）, 允许有文本，不允许有子元素;</li>
<li>空内容（empty content）, 文本与子元素都不被允许;</li>
<li>混合内容（mixed content）, 文本与子元素都可以有.</li>
</ul>
<p>复杂数据类型可以从别的复杂类型导出：</p>
<ul>
<li>restriction方法，不允许基类型允许的一些元素、属性或者值</li>
<li>extension方法，允许额外的属性或元素出现。</li>
</ul>
<p>XSD 1.1又增加了assertion方法来约束复杂类型, 即通过一个[XPath 2.0]]表达式必须求值为真</p>
<h2><span id="Schema_.E6.97.A2.E9.AA.8C.E4.BF.A1.E6.81.AF.E9.9B.86.EF.BC.88Post-Schema-Validation_Infoset.EF.BC.89"><span id="Schema_既验信息集（Post-Schema-Validation_Infoset）" class="mw-headline">Schema 既验信息集（Post-Schema-Validation Infoset）</span></span></h2>
<p>基于 Schema 的验证完成后，可以按照 Schema 所隐含的数据模型来表达文档的结构与内容。XML Schema 数据模型包括：</p>
<ul>
<li>词汇（元素与属性名称集）</li>
<li>内容模型（关联与结构）</li>
<li>数据类型</li>
</ul>
<p>这些信息的集合即为 Schema 既验信息集（Post-Schema-Validation Infoset （PSVI））。对于有效的 XML，PSVI 给它赋以特定的&ldquo;类型&rdquo;，从而便于以对象方式来处理整个文档，并应用面向对象程序设计（OOP）范式。</p>
<h2><span id="XML_Schema.E7.9A.84.E6.AC.A1.E8.A6.81.E7.94.A8.E9.80.94"><span id="XML_Schema的次要用途" class="mw-headline">XML Schema的次要用途</span></span></h2>
<p>XML Schema的主要用途是形式描述XML文档，然而最终的schema除了简单验证文档外还有许多其他用途。</p>
<h3><span id=".E4.BB.A3.E7.A0.81.E7.94.9F.E6.88.90"><span id="代码生成" class="mw-headline">代码生成</span></span></h3>
<p>Schema可用于生成代码，这称作{[tsl|en|XML Data Binding}}。这些代码允许XML文档的内容作为编程环境中的对象。</p>
<h3><span id="XML.E6.96.87.E4.BB.B6.E7.BB.93.E6.9E.84.E6.96.87.E6.A1.A3.E7.9A.84.E7.94.9F.E6.88.90"><span id="XML文件结构文档的生成" class="mw-headline">XML文件结构文档的生成</span></span></h3>
<p>Schema可用于产生人可读的文档来描述一个XML文件的结构。这在作者利用了标记元素（annotation element）时非常有用。</p>
<h2><span id=".E6.89.B9.E8.AF.84"><span id="批评" class="mw-headline">批评</span></span></h2>
<p>虽然XML Schema获取了广泛的成功应用，但也受到了大量严厉的批评，远超出其他W3C推荐标准。下述研究者很好地总结了这些批评：James Clark,<sup id="cite_ref-1" class="reference"><a href="https://zh.wikipedia.org/wiki/XML_Schema#cite_note-1">[1]</a></sup>&nbsp;Anders M&oslash;ller与Michael Schwartzbach,<sup id="cite_ref-2" class="reference"><a href="https://zh.wikipedia.org/wiki/XML_Schema#cite_note-2">[2]</a></sup>&nbsp;Rick Jelliffe<sup id="cite_ref-3" class="reference"><a href="https://zh.wikipedia.org/wiki/XML_Schema#cite_note-3">[3]</a></sup>，David Webber.<sup id="cite_ref-4" class="reference"><a href="https://zh.wikipedia.org/wiki/XML_Schema#cite_note-4">[4]</a></sup></p>
<p>一般问题:</p>
<ul>
<li>推荐标准数百页，语句非常技术化，对于非专业的用户来说过于复杂难读。很多人发现<a class="external text" href="http://www.w3.org/TR/xmlschema-0/" rel="nofollow">W3Cs XML Schema Primer</a>更易于理解.</li>
<li>XSD缺少形式化数学规范，这使得关于schema的自动推理很困难，例如证明一个修改过的schema是<a class="mw-redirect" title="向后兼容" href="https://zh.wikipedia.org/wiki/%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9">向后兼容</a>的。</li>
<li>语言中有很多例外，如元素的限制（restriction）不同于属性的限制。</li>
</ul>
<p>表达能力的实践限制:</p>
<ul>
<li>XSD对无序内容提供了极少支持</li>
<li>XSD不能要求提供<em>root element</em>&nbsp;(因而要求额外的信息来验证即使最简单的文档).</li>
<li>在描述<em>mixed content</em>, 没有任何方式约束字符内容(甚至没办法指定一个有效字符集).</li>
<li><em>内容与属性声明不能依赖于元素或属性上下文</em>&nbsp;(这也是DTD的一个大问题).</li>
<li><em>不是100%自描述</em>&nbsp;(上一点就是个例子), 即使有这样的初始设计需求.</li>
<li><em>默认</em>不能被独立于声明被指定(这使其不能给出一族schema尽在默认值上不同);<em>元素默认</em>只能是字符数据(不包含markup).</li>
</ul>
<p>技术问题:</p>
<ul>
<li>虽然从技术上遵从名字空间，但看起来并不追随名字空间的精神原则。(例如 "unqualified locals").</li>
<li>XSD 1.0不提供机制，使得一个属性的值或者存在依赖于另一个属性的值或存在(被称为<em>co-occurrence constraints</em>). XSD 1.1解决了这个问题.</li>
<li>XSD数据类型的范围非常随意.<sup id="cite_ref-5" class="reference"><a href="https://zh.wikipedia.org/wiki/XML_Schema#cite_note-5">[5]</a></sup></li>
<li>验证与扩增(augmentation，增加类型信息与默认值)应该保持分离。</li>
</ul>
<h2><span id=".E7.A4.BA.E8.8C.83"><span id="示范" class="mw-headline">示范</span></span></h2>
<p>一个Schema的简易示例，描述某个指定的国家，是这样的：</p>
<pre><code>&lt;xs:schema
 xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
   &lt;xs:element name="country" type="Country"&gt;
     &lt;xs:complexType name="Country"&gt;
      &lt;xs:sequence&gt;
       &lt;xs:element name="name" type="xs:string"/&gt;
       &lt;xs:element name="population" type="xs:decimal"/&gt;
      &lt;/xs:sequence&gt;
     &lt;/xs:complexType&gt;
   &lt;/xs:element&gt;
&lt;/xs:schema&gt;
</pre>
<p>一份遵从这个视图的XML文件：</p>
<pre><code>&lt;country
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:noNamespaceSchemaLocation="country.xsd"&gt;
  &lt;name&gt;France&lt;/name&gt;
  &lt;population&gt;59.7&lt;/population&gt;
&lt;/country&gt;</pre>
</div>
</div>
</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>