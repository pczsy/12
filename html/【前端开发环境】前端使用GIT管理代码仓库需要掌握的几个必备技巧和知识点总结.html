<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修【前端开发环境】前端使用GIT管理代码仓库需要掌握的几个必备技巧和知识点总结' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>【前端开发环境】前端使用GIT管理代码仓库需要掌握的几个必备技巧和知识点总结</center></div><div class='banquan'>原文出处:本文由博客园博主Web前端社区提供。<br/>
原文连接:https://www.cnblogs.com/fecommunity/p/11914618.html</div><br>
    <h2 id="git的三种状态">1. Git的三种状态</h2>
<ul>
<li>已提交 committed</li>
<li>已暂存 staged</li>
<li>已修改 modified</li>
</ul>
<h2 id="git的三个区域">2. Git的三个区域</h2>
<ol>
<li>Git仓库
<ul>
<li>是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</li>
</ul></li>
<li>暂存区域
<ul>
<li>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’'，不过一般说法还是叫暂存区域。</li>
</ul></li>
<li>工作目录
<ul>
<li>工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li>
</ul></li>
</ol>
<h2 id="基本的-git-工作流程">3. 基本的 Git 工作流程</h2>
<ol>
<li>在工作目录修改文件</li>
<li>暂存文件，将文件的快照放入暂存区</li>
<li>提交更新，找到暂存去文件，将快照永久性存储到 Git 仓库目录。</li>
</ol>
<h3 id="用户信息">3.1 用户信息</h3>
<blockquote>
<p>[!NOTE]<br />
当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改。</p>
</blockquote>
<pre><code><code>git config --global user.name &quot;huyaocode&quot;
git config --global user.email johndoe@example.com</code></pre>
<h3 id="加入暂存区">3.2 加入暂存区</h3>
<pre><code><code>git add 文件名或路径</code></pre>
<h3 id="忽略文件">3.3 忽略文件</h3>
<p>创建一个<code>.gitignore</code>文件，可描述需要忽略的文件。 参考</p>
<pre class="py"><code># no .a files
*.a
# but do track lib.a, even though you&#39;re ignoring .a files above
!lib.a
# 只忽略当前文件夹下已 TODO 为名的文件
/TODO
# 忽略当前目录下 build 这个文件夹
build/
# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt
# ignore all .pdf files in the doc/ directory
doc/**/*.pdf</code></pre>
<h3 id="状态修改">3.4 状态修改</h3>
<p><code>git status -s</code>将每个修改状态以一行展示，也可以用<code>git status</code>多行展示。</p>
<ul>
<li><code>A</code> 新添加到暂存区中的文件</li>
<li><code>M</code> 修改过的文件</li>
<li><code>D</code> 被删除的文件</li>
<li><code>MM</code> 出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。</li>
<li><code>??</code> 未跟踪</li>
</ul>
<h3 id="查看修改">3.5 查看修改</h3>
<ul>
<li>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code></li>
<li>要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --cached</code> 或 <code>git diff --staged</code></li>
</ul>
<h3 id="提交修改">3.6 提交修改</h3>
<p>运行<code>git commit</code>，会出现如下情况。这种方式会启动文本编辑器，开头还有一空行，供你输入提交说明。下面的行是被注释了的，也可以取消这些注释。</p>
<p>一般是vim 或 emacs。当然也可以按照 起步 介绍的方式，使用 <code>git config --global core.editor</code> 命令设定你喜欢的编辑软件。</p>
<p>也可以使用<code>git commit -m &quot;修改描述&quot;</code> 这种直接输入描述的方式提交修改。</p>
<p><code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</p>
<h3 id="移除文件">3.7 移除文件</h3>
<p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。<br />
可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>
<p>运行 <code>git rm</code>记录此次移除文件的操作。下一次提交时，该文件就不再纳入版本管理了。 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，<br />
这样的数据不能被 Git 恢复。</p>
<p>想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。(不想让Git跟踪)</p>
<pre><code><code>git rm --cached 某文件</code></pre>
<h3 id="文件更名">3.8 文件更名</h3>
<pre><code><code>git mv file_from file_to</code></pre>
<p>其实，运行 git mv 就相当于运行了下面三条命令：</p>
<pre><code><code>mv README.md README
git rm README.md
git add README</code></pre>
<h3 id="查看提交历史">3.9 查看提交历史</h3>
<blockquote>
<p>[!NOTE]<br />
<code>git log</code>git log 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p>
</blockquote>
<p>使用 <code>-p</code> 用来限制展示条数。<code>git log -p -2</code></p>
<p>使用 <code>--stat</code> 选项看到每次提</p>
<p>使用<code>format</code>，定制要显示的记录格式。</p>
<p>使用<code>--graph</code>可形象地展示你的分支、合并历史。</p>
<pre><code><code>$ git log --pretty=format:&quot;%h %s&quot; --graph
* 2d3acf9 ignore errors from SIGCHLD on trap
* 5e3ee11 Merge branch &#39;master&#39; of git://github.com/dustin/grit
|\
| * 420eac9 Added a method for getting the current branch.
* | 30e367c timeout code and tests
* | 5a09431 add timeout protection to grit
* | e1193f8 support for heads with slashes in them
|/
* d6016bc require time for xmlschema
* 11d191e Merge branch &#39;defunkt&#39; into local</code></pre>
<h3 id="重新提交">3.10 重新提交</h3>
<blockquote>
<p>[!NOTE]<br />
有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交。</p>
</blockquote>
<pre><code><code>git commit --amend</code></pre>
<p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p>
<p>文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。</p>
<p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p>
<pre><code><code>git commit -m &#39;initial commit&#39;
git add forgotten_file
git commit --amend</code></pre>
<p>最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。</p>
<h3 id="取消暂存的文件">3.11 取消暂存的文件</h3>
<p>使用 <code>git reset HEAD &lt;file&gt;</code> 来取消暂存。在调用时加上 --hard 选项可以令 git reset 成为一个危险的命令（译注：可能导致工作目录中所有当前进度丢失！）</p>
<h3 id="撤消对文件的修改">3.12 撤消对文件的修改</h3>
<p>使用<code>git checkout -- &lt;file&gt;</code> 可以撤销修改（未保存到暂存区）</p>
<h2 id="什么是-git-复刻fork复刻fork分支branch和克隆clone之间有什么区别">4. 什么是 Git 复刻（fork）？复刻（fork）、分支（branch）和克隆（clone）之间有什么区别？</h2>
<ol>
<li><strong>复刻（fork）</strong> 是对存储仓库（repository）进行的远程的、服务器端的拷贝，从源头上就有所区别。复刻实际上不是 Git 的范畴。它更像是个政治/社会概念。</li>
<li><strong>克隆（clone）</strong>不是复刻，克隆是个对某个远程仓库的本地拷贝。克隆时，实际上是拷贝整个源存储仓库，包括所有历史记录和分支。</li>
<li><strong>分支（branch）</strong> 是一种机制，用于处理单一存储仓库中的变更，并最终目的是用于与其他部分代码合并。</li>
</ol>
<h2 id="拉取请求pull-request和分支branch之间有什么区别">5. “拉取请求（pull request）”和“分支（branch）”之间有什么区别？</h2>
<ol>
<li><strong>分支（branch）</strong> 是代码的一个独立版本。</li>
<li><strong>拉取请求（pull request）</strong> 是当有人用仓库，建立了自己的分支，做了些修改并合并到该分支（把自己修改应用到别人的代码仓库）。</li>
</ol>
<h2 id="git-pull和git-fetch之间有什么区别">6. “git pull”和“git fetch”之间有什么区别？</h2>
<ol>
<li><p>简单来说，git pull 是 git fetch + git merge。</p></li>
<li><p>当你使用 pull，Git 会试着自动为你完成工作。它是上下文（工作环境）敏感的，所以 Git 会把所有拉取的提交合并到你当前处理的分支中。pull 则是 自动合并提交而没有让你复查的过程。如果你没有细心管理你的分支，你可能会频繁遇到冲突。</p></li>
<li><p>当你 fetch，Git 会收集目标分支中的所有不存在的提交，并将这些提交存储到本地仓库中。但Git 不会把这些提交合并到当前分支中。这种处理逻辑在当你需要保持仓库更新，在更新文件时又希望处理可能中断的事情时，这将非常实用。而将提交合并到主分支中，则该使用 merge。</p></li>
</ol>
<h2 id="如在-git-恢复先前的提交">7. 如在 Git 恢复先前的提交？</h2>
<p>假设你的情形是这样，其中 C 是你的 HEAD，(F) 是你文件的状态。</p>
<pre><code><code>   (F)
A-B-C
    ↑
  master

   (F)
A-B-C
    ↑
  master
要修改提交中的更改：
git reset --hard HEAD~1
1
git reset --hard HEAD~1
现在B是 HEAD，因为你使用了 --hard，所以你的文件将重置到提交 B 时的状态。

要撤销提交但保留更改：
git reset HEAD~1
1
git reset HEAD~1
现在我们告诉 Git 将 HEAD 指针移回（后移）一个提交（B），并保留文件原样，然后你可以 git status 来显示你已经检入 C 的更改。

撤销提交但保留文件和索引：
git reset --soft HEAD~1
1
git reset --soft HEAD~1
执行此操作后，git status，你讲看到索引中的文件跟以前一致。</code></pre>
<h2 id="什么是git-cherry-pick">8. 什么是“git cherry-pick”？</h2>
<blockquote>
<p>[!NOTE]<br />
命令 git cherry-pick 通常用于把特定提交从存储仓库的一个分支引入到其他分支中。常见的用途是从维护的分支到开发分支进行向前或回滚提交。</p>
</blockquote>
<p>这与其他操作（例如：合并（merge）、变基（rebase））形成鲜明对比，后者通常是把许多提交应用到其他分支中。</p>
<p>小结：</p>
<pre><code><code>git cherry-pick &lt;commit-hash&gt;
1
git cherry-pick &lt;commit-hash&gt;</code></pre>
<h2 id="解释-forking-工作流程的优点">9. 解释 Forking 工作流程的优点?</h2>
<ol>
<li><p>Forking 工作流程 与其他流行的 Git 工作流程有着根本的区别。它不是用单个服务端仓库充当“中央”代码库，而是为每个开发者提供自己的服务端仓库。Forking 工作流程最常用于公共开源项目中。</p></li>
<li><p>Forking 工作流程的主要优点是可以汇集提交贡献，又无需每个开发者提交到一个中央仓库中，从而实现干净的项目历史记录。开发者可以推送（push）代码到自己的服务端仓库，而只有项目维护人员才能直接推送（push）代码到官方仓库中。</p></li>
<li><p>当开发者准备发布本地提交时，他们的提交会推送到自己的公共仓库中，而不是官方仓库。然后他们向主仓库提交请求拉取（pull request），这会告知项目维护人员有可以集成的更新。</p></li>
</ol>
<h2 id="告诉我-git-中-head工作树和索引之间的区别">10. 告诉我 Git 中 HEAD、工作树和索引之间的区别？</h2>
<ol>
<li>该工作树/工作目录/工作空间是你看到和编辑的（源）文件的目录树。</li>
<li>该索引/中转区（staging area）是个在 /.git/index，单一的、庞大的二进制文件，该文件列出了当前分支中所有文件的 SHA1 检验和、时间戳和文件名，它不是个带有文件副本的目录。</li>
<li>HEAD是当前检出分支的最后一次提交的引用/指针。</li>
</ol>
<h2 id="你能解释下-gitflow-工作流程吗">11. 你能解释下 Gitflow 工作流程吗？</h2>
<blockquote>
<p>[!NOTE]<br />
Gitflow 工作流程使用两个并行的、长期运行的分支来记录项目的历史记录，分别是 master 和 develop 分支。</p>
</blockquote>
<ol>
<li>Master，随时准备发布线上版本的分支，其所有内容都是经过全面测试和核准的（生产就绪）。</li>
<li>Hotfix，维护（maintenance）或修复（hotfix）分支是用于给快速给生产版本修复打补丁的。修复（hotfix）分支很像发布（release）分支和功能（feature）分支，除非它们是基于 master 而不是 develop 分支。</li>
<li>Develop，是合并所有功能（feature）分支，并执行所有测试的分支。只有当所有内容都经过彻底检查和修复后，才能合并到 master 分支。</li>
<li>Feature，每个功能都应留在自己的分支中开发，可以推送到 develop 分支作为功能（feature）分支的父分支。</li>
</ol>
<h2 id="什么时候应使用-git-stash">12. 什么时候应使用 “git stash”？</h2>
<blockquote>
<p>[!NOTE]<br />
git stash 命令把你未提交的修改（已暂存（staged）和未暂存的（unstaged））保存以供后续使用，以后就可以从工作副本中进行还原。</p>
</blockquote>
<p>回顾：</p>
<pre><code><code>$ git status
On branch master
Changes to be committed:
new file: style.css
Changes not staged for commit:
modified: index.html
$ git stash
Saved working directory and index state WIP on master: 5002d47 our new homepage
HEAD is now at 5002d47 our new homepage
$ git status
On branch master
nothing to commit, working tree clean

$ git status
On branch master
Changes to be committed:
new file: style.css
Changes not staged for commit:
modified: index.html
$ git stash
Saved working directory and index state WIP on master: 5002d47 our new homepage
HEAD is now at 5002d47 our new homepage
$ git status
On branch master
nothing to commit, working tree clean
我们可以使用暂存（stash）的一个地方是，如果我们发现在上次提交中忘记了某些内容，并且已经开始在同一分支中处理下一个提交了：

# Assume the latest commit was already done
# start working on the next patch, and discovered I was missing something

# stash away the current mess I made
$ git stash save

# some changes in the working dir

# and now add them to the last commit:
$ git add -u
$ git commit --ammend

# back to work!
$ git stash pop

# Assume the latest commit was already done
# start working on the next patch, and discovered I was missing something

# stash away the current mess I made
$ git stash save

# some changes in the working dir

# and now add them to the last commit:
$ git add -u
$ git commit --ammend

# back to work!
$ git stash pop</code></pre>
<h2 id="如何从-git-中删除文件而不将其从文件系统中删除">13. 如何从 git 中删除文件，而不将其从文件系统中删除？</h2>
<p>如果你在 git add 过程中误操作，你最终会添加不想提交的文件。但是，git rm 则会把你的文件从你暂存区（索引）和文件系统（工作树）中删除，这可能不是你想要的。</p>
<p>换成 git reset 操作：</p>
<p>git reset filename # or<br />
echo filename &gt;&gt; .gitingore # add it to .gitignore to avoid re-adding it<br />
1<br />
2<br />
git reset filename # or<br />
echo filename &gt;&gt; .gitingore # add it to .gitignore to avoid re-adding it<br />
上面意思是，git reset <paths> 是 git add <paths> 的逆操作。</p>
<h2 id="是么时候使用git-rebase代替git-merge">14. 是么时候使用“git rebase”代替“git merge”？</h2>
<blockquote>
<p>[!NOTE]<br />
这两个命令都是把修改从一个分支集成到另一个分支上，它们只是以非常不同的方式进行。</p>
</blockquote>
<p>考虑一下场景，在合并和变基前：</p>
<p>A &lt;- B &lt;- C [master]<br />
^<br />

 D &lt;- E [branch]<br />
1<br />
2<br />
3<br />
4<br />
A &lt;- B &lt;- C [master]<br />
^<br />

 D &lt;- E [branch]<br />
在 git merge master 之后：</p>
<p>A &lt;- B &lt;- C<br />
^ ^<br />
  
 D &lt;- E &lt;- F<br />
1<br />
2<br />
3<br />
4<br />
A &lt;- B &lt;- C<br />
^ ^<br />
  
 D &lt;- E &lt;- F<br />
在 git rebase master 之后：</p>
<p>A &lt;- B &lt;- C &lt;- D &lt;- E<br />
1<br />
A &lt;- B &lt;- C &lt;- D &lt;- E<br />
使用变基时，意味着使用另一个分支作为集成修改的新基础。</p>
<h3 id="何时使用">14.1 何时使用</h3>
<p>如果你对修改不够果断，请使用合并操作。<br />
根据你希望的历史记录的样子，而选择使用变基或合并操作。</p>
<h3 id="更多需要考虑的因素">14.2 更多需要考虑的因素</h3>
<ol>
<li>分支是否与团队外部的开发人员共享修改（如开源、公开项目）？如果是这样，请不要使用变基操作。变基会破坏分支，除非他们使用 git pull --rebase，否则这些开发人员将会得到损坏的或不一致的仓库。</li>
<li>你的开发团队技术是否足够娴熟？变基是一种破坏性操作。这意味着，如果你没有正确使用它，你可能会丢失提交，并且/或者会破坏其他开发者仓库的一致性。</li>
<li>分支本身是否代表有用的信息？一些团队使用功能分支（branch-per-feature）模式，每个分支代表一个功能（或错误修复，或子功能等）。在此模式中，分支有助于识别相关提交的集合。在每个开发人员分支（branch-per-developer）模式中，分支本身不会传达任何其他信息（提交信息已有作者）。则在这种模式下，变基不会有任何破坏。</li>
<li>是否无论如何都要还原合并？恢复（如在撤销中）变基，是相当困难的，并且/或者在变基中存在冲突时，是不可能完成的。如果你考虑到日后可能需要恢复，请使用合并操作。</li>
</ol>
<hr />
<p><strong>参考资料</strong></p>
<ul>
<li>Git在线学习：https://learngitbranching.js.org/?NODEMO</li>
<li>参考博客：https://www.cnblogs.com/ludashi/p/8323617.html</li>
</ul>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>