<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修css — 权重、继承性、排版、float' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>css — 权重、继承性、排版、float</center></div><div class='banquan'>原文出处:本文由博客园博主一直努力的小羊提供。<br/>
原文连接:https://www.cnblogs.com/yangjie0906/p/11405155.html</div><br>
    <div class="toc">
    <p class="toc-title">目录</p>
    <div class="toc-list">
        <ul>
        <li><a href="#继承性">1. 继承性</a></li>
        <li><a href="#css中的权重">2. css中的权重</a></li>
        <li><a href="#常用格式化排版">3. 常用格式化排版</a></li>
        <li><a href="#浮动布局float">4. 浮动布局float</a></li>
        </ul>
    </div>
</div>
<h3 id="继承性">1. 继承性</h3>
<p>继承性：在css有某些属性是可以继承下来，如 color,text-xxx,line-height,font-xxx,letter-spacing,word-spacing是可以继承下来，但有些属性是不可以继承下来的，如 border:1px solid green;</p>
<h3 id="css中的权重">2. css中的权重</h3>
<p>继承来的属性权重值约为0</p>
<p>权重比较规则:</p>
<ul>
<li>如果选中了标签：
<ul>
<li>1.数选择器数量： id 类 标签 ，谁大它的优先级越高，如果一样大，后面的会覆盖掉前面的属性</li>
<li>2.选中的标签的属性优先级用于大于继承来的属性，它们是没有可比性</li>
<li>3.同是继承来的属性
<ul>
<li>1.谁描述的近，谁的优先级越高</li>
<li>2.描述的一样近，这个时候才回归到数选择器的数量</li>
</ul></li>
</ul></li>
</ul>
<p><img src="./images/css — 权重、继承性、排版、float0.png" /></p>
<p>!important 它设置当前属性的权重为无限大，大不过行内样式的优先级</p>
<p>注意：!important要写在分号的前面</p>
<p>使用!important是一个坏习惯，应该尽量避免，因为这严重破坏了样式表中固有的权值比较规则，使得在调试bug变得更加困难。</p>
<h3 id="常用格式化排版">3. 常用格式化排版</h3>
<h4 id="字体属性">3.1 字体属性</h4>
<p>1.字体</p>
<p>语法：</p>
<pre><code><code>/*网页中的文字设置字体为微软雅黑*/
body{font-family:&quot;Microsoft Yahei&quot;}</code></pre>
<p>2.备选字体</p>
<p>语法：</p>
<pre><code><code>body{font-family:&#39;Microsoft Yahei&#39;,&#39;宋体&#39;,&#39;黑体&#39;;font-size: 14px}</code></pre>
<p>备选字体可以有无数个，那么浏览器在去解析这个代码的时候，是从左往右解析的，如果没有微软雅黑，再去找宋体，最后黑体。</p>
<p>3.字体大小</p>
<p>字体大小单位：px、em、rem,一般浏览器的字体大小默认为为16px。</p>
<p>语法：</p>
<pre><code><code>boy{font-size: 20px;}</code></pre>
<p>px是绝对单位也叫固定尺寸，不管在多少尺寸的屏幕下,始终是当前的尺寸</p>
<p>em相对单位,相对于当前盒子的字体大小</p>
<pre><code><code>.box{
    font-size: 20px;
    /*1em = 20px*/
    width: 20em;
    height: 20em;
    background-color: red;
}</code></pre>
<p>rem相对单位,相对于根元素（html）的字体大小</p>
<pre><code><code>html{
    font-size: 40px;
}
.box{
    /*1rem = 40px  1px  = 0.025rem */
    /*1 : 0.025 = 400 : ?*/
    font-size: 12px;
    width: 20rem;
    height: 20rem;
    background-color: red;
}</code></pre>
<p>4.字体样式</p>
<p>norma 默认的，文本设置为普通字体</p>
<p>italic 斜体字体</p>
<p>oblique 倾斜字体</p>
<p>语法：</p>
<pre><code><code>{font-style: italic;}</code></pre>
<p>5.字体粗细</p>
<p>normal 普通的字体粗细，默认的，相当于数字值400</p>
<p>bold 加粗的字体粗细,相当于数字值700</p>
<p>lighter 比普通字体更细的字体</p>
<p>bolder 比bold更粗的字体，相当于数字值900</p>
<p>数字值：100~900，取值范围：100、200、300、400、500、600、700、800、900</p>
<p>语法：</p>
<pre><code><code>{font-weight: 700;}</code></pre>
<h4 id="文本属性">3.2 文本属性</h4>
<p>1.文本修饰</p>
<p>none 无文本的修饰</p>
<p>underline 文本下划线</p>
<p>overline 文本上划线</p>
<p>line-through 穿过文本的线，<del>可以模拟删除线</del>。</p>
<p>语法：</p>
<pre><code><code>#box p:hover{
    text-decoration: underline;
}</code></pre>
<p>2.文本缩进</p>
<p>语法：</p>
<pre><code><code>#box2{
    /*字体大小*/
    font-size: 20px;
    /*设置文本缩进*/
    text-indent: 2em;
}</code></pre>
<p>3.中文字间距、英文单词间距</p>
<pre><code><code>#box2{
    /*字体大小*/
    font-size: 20px;
    /*设置文字之间的间距*/
    letter-spacing: 2px;
    /*设置英文单词之间的间距*/
    word-spacing: 10px;
}</code></pre>
<p>4.文本对齐</p>
<p>left 靠左</p>
<p>center 居中</p>
<p>right 靠右</p>
<p>justify 仅限于对英文的两端对齐</p>
<p>语法：</p>
<pre><code><code>{text-align: center;}</code></pre>
<h3 id="浮动布局float">4. 浮动布局float</h3>
<h4 id="浮动的介绍">4.1 浮动的介绍</h4>
<p>浮动是网页布局中非常重要的一个属性。那么 浮动 这个属性一开始设计的初衷是为了网页的 文字环绕效果 。</p>
<p>例：如果让两个div在一排内显示，那怎么办，可能有的同学会说使用display属性啊，把他们设置成inline-block。但是，你会发现两个div盒子中间有间隙，仅仅的这点间隙，到底是多大呢，如果我们在一行内计算整个盒模型的宽度的话，是否又计算的精准呢？所以使用display的方法是不对的，这时我们就用到了浮动属性 ，浮动可以实现元素并排。</p>
<h4 id="浮动属性">4.2 浮动属性</h4>
<p>none 表示不浮动，所有之前讲解的HTML标签默认不浮动</p>
<p>left 左浮动</p>
<p>right 右浮动</p>
<p>inherit 继承父元素的浮动属性</p>
<p>语法：</p>
<pre><code><code>box{
    float: left;
}</code></pre>
<h4 id="浮动的现象">4.3 浮动的现象</h4>
<p>1.我们之前说浮动的设计初衷是为了做”文字环绕效果“。那么我们就来看一下如果对盒子设置了浮动，会产生什么现象？</p>
<ul>
<li><p>1.脱离标准文档流，不在页面上占位置 ，即“脱标”</p></li>
<li><p>2.产生‘文字环绕’的效果 ，设置浮动属性的初衷</p></li>
<li><p>3.“贴边” 现象： 给盒子设置了浮动，会找浮动盒子的边，如果找不到浮动盒子的边，会贴到父元素的边，如果找到了，就会贴到浮动盒子的边上</p>
<p>出现贴边现象的原因：</p>
<ul>
<li>当一个元素浮动之后，它会被移出正常的文档流，然后向左或者向右平移，一直平移直到碰到了所处的容器的边框，或者碰到另外一个浮动的元素的边框</li>
</ul></li>
<li><p>4.收缩效果</p>
<ul>
<li>在没有给盒子设置浮动之前，盒子是占据一整行的，一旦设置了浮动那么盒子的宽度就是内容的宽度了。</li>
</ul></li>
</ul>
<pre><code><code>&lt;style&gt;
    *{
        padding: 0;
        margin: 0;
    }
    .father{
        width: 800px;
        margin: 100px auto;
        height: 400px;
        border: 1px solid #000;
    }
    .child1{
        /*width: 200px;*/
        height: 400px;
        background-color: red;
        float: left;
    }
    .child2{
        /*width: 300px;*/
        height: 200px;
        background-color: green;
        float: right;
    }
&lt;/style&gt;

&lt;body&gt;
    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;child1&quot;&gt;mjj&lt;/div&gt;
        &lt;div class=&quot;child2&quot;&gt;wusir&lt;/div&gt;
    &lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>2.标准文档流</p>
<p>文档流指的是元素排版布局过程中，元素会<strong>默认</strong>自动从左往后、从上往下的流式排列方式。</p>
<p>即不对页面进行任何布局控制时，浏览器默认的HTML布局方式，这种布局方式从左往右，从上往下，有点像流水的效果，我们称为<code>流式布局</code>。</p>
<p>3.浮动带来的问题 ：</p>
<p>不去计算浮动元素的高度，撑不起父盒子的高度</p>
<h4 id="清除浮动的方式">4.4 清除浮动的方式</h4>
<p>1.给父元素添加固定高度</p>
<ul>
<li>问题：不灵活，后期不易维护</li>
<li>应用：万年不变导航栏</li>
</ul>
<p>2.内墙法</p>
<ul>
<li><p>给最后一个浮动元素的后面添加一个空的块级标签，并且设置该标签的属性为clear:both;</p></li>
<li><p>问题：太冗余了</p>
<pre><code><code>&lt;style&gt;
  .clear{
            clear: both;
        }
&lt;/style&gt;
&lt;div class=&quot;father clearfix&quot;&gt;
    &lt;div class=&quot;child1&quot;&gt;mjj&lt;/div&gt;
    &lt;div class=&quot;child2&quot;&gt;wusir&lt;/div&gt;
    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre></li>
</ul>
<p>3.伪元素清除法 （推荐大家使用）</p>
<p>给父元素添加一个类</p>
<pre><code><code>.clearfix::after{
    content:&#39;&#39;;
    display: block;
    clear: both;
    
    /*在content:&#39;有内容的时候&#39;; 上面三行代码 + 下面两行代码*/
    /*visibility: hidden;*/  /*把内容隐藏*/
    /*height: 0;*/  /*内容隐藏后的高度设置为0*/
}</code></pre>
<p>4.overflow:hidden; （常用）</p>
<p>CSS属性overflow定义一个元素的内容太大而无法适应盒子的时候该做什么。</p>
<p>visible 默认属性，可见</p>
<p>hidden 内容会被修剪，并且超出内容会隐藏、不可见</p>
<p>scroll 内容会被修剪，浏览器会显示滚动条以便查看超出内容</p>
<p>auto 由浏览器定夺，如果内容被修剪，就会显示滚动条</p>
<p>inherit 规定从父元素继承overflow属性的值</p>
<p>当一个元素设置了overflow:hidden|auto|scroll属性之后，它会形成一个BFC区域，我们叫做它为<strong>块级格式化上下文</strong>。BFC只是一个规则，它对浮动定位都很重要，浮动定位和清除浮动只会应用于同一个BFC的元素。</p>
<p>浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。</p>
<p>总结：只要我们让父盒子形成BFC的区域，那么它就会清除区域中浮动元素带来的影响。</p>
<p>因为overflow:hidden;会形成BFC区域，形成BFC区域之后，内部有它的布局规则<br />
计算BFC的高度时，浮动元素也参与计算。</p>
<p>注意：小心overflow：hidden；它自己的本意</p>
<pre><code><code> .box{
            width: 300px;
            height: 300px;
            border: 1px solid #000;
            /*overflow: visible;!*默认可见*!*/
            overflow: hidden;
            /*overflow: scroll;*/
            /*overflow: inherit;*/
        }</code></pre>
<p>5.BFC</p>
<ul>
<li><p>1.BFC 定义</p>
<p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p></li>
<li><p>2.BFC布局规则</p>
<ul>
<li>1.内部的Box会在垂直方向，一个接一个地放置。</li>
<li>2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>
<li>3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>
<li>4.BFC的区域不会与float 元素重叠。</li>
<li>5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li>6.计算BFC的高度时，浮动元素也参与计算`</li>
</ul></li>
<li><p>3.哪些元素会生成BFC</p>
<ul>
<li>1.根元素</li>
<li>2.float属性不为none</li>
<li>3.position为absolute或fixed</li>
<li>4.display为inline-block</li>
<li>5.overflow不为visible</li>
</ul></li>
</ul>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>