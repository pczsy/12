<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修前端-CSS' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>前端-CSS</center></div><div class='banquan'>原文出处:本文由博客园博主lsf123456提供。<br/>
原文连接:https://www.cnblogs.com/lsf123456/p/11248773.html</div><br>
    <h1><span style="font-size: 18pt;">一、概述</span></h1>
<p><span style="font-size: 16px;">CSS是Cascading Style Sheets的简称，中文称为层叠样式表，用来控制网页数据的表现，可以<strong>使网页的表现与数据内容分离</strong>。</span></p>
<h1><span style="font-size: 18pt;">二、CSS的引入方式</span></h1>
<h2><span style="font-size: 14pt;">1. 行内式</span></h2>
<p><span style="font-size: 16px;">行内式是在标记的style属性中设定CSS样式。这种方式没有体现出CSS的优势，不推荐使用。</span></p>
<div class="cnblogs_Highlighter">
<pre><code>&lt;span style="color:red;"&gt;行内式&lt;/span&gt;  
</pre>
</div>
<h2><span style="font-size: 14pt;">2. 嵌入式</span></h2>
<p><span style="font-size: 16px;">嵌入式是将CSS样式集中写在网页的&lt;head&gt;&lt;/head&gt;标签对的&lt;style&gt;&lt;/style&gt;标签对中。</span></p>
<div class="cnblogs_Highlighter">
<pre><code>&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        p{
            background-color: #2b99ff;
        }
    &lt;/style&gt;
&lt;/head&gt;
</pre>
</div>
<h2><span style="font-size: 14pt;">3. 链接式</span></h2>
<p><span style="font-size: 16px;">在head标签内引入css文件</span></p>
<div class="cnblogs_Highlighter">
<pre><code>&lt;link rel="stylesheet" type="text/css" href="css/abc.css"/&gt;</pre>
</div>
<h2><span style="font-size: 14pt;">4. 导入式</span></h2>
<p><span style="font-size: 16px;">将一个独立的.css文件引入HTML文件中，导入式使用CSS规则引入外部CSS文件，&lt;style&gt;标记也是写在&lt;head&gt;标记中</span></p>
<div class="cnblogs_Highlighter">
<pre><code>&lt;style type="text/css"&gt;
	@import url("global.css");
&lt;/style&gt;</pre>
</div>
<p><span style="font-size: 15px;">注意：导入式会在整个网页装载完后再装载CSS文件，因此这就导致了一个问题，如果网页比较大则会儿出现先显示无样式的页面，闪烁一下之后，再出现网页的样式。这是导入式固有的一个缺陷。使用链接式时与导入式不同的是它会以网页文件主体装载前装载CSS文件，因此显示出来的网页从一开始就是带样式的效果的，它不会象导入式那样先显示无样式的网页，然后再显示有样式的网页，这是链接式的优点。</span></p>
<h1><span style="font-size: 18pt;">三、CSS选择器</span></h1>
<p><span style="font-size: 16px;">&ldquo;选择器&rdquo;指明了{}中的&ldquo;样式&rdquo;的作用对象，也就是&ldquo;样式&rdquo;作用于网页中的哪些元素</span></p>
<h2><span style="font-size: 14pt;">1. 基础选择器</span></h2>
<div class="cnblogs_Highlighter">
<pre><code>＊ ：          通用元素选择器，匹配任何元素                    * { margin:0; padding:0; }

E  ：          标签选择器，匹配所有使用E标签的元素               p { color:green; }

.info和E.info: class选择器，匹配所有class属性中包含info的元素   .info { background:#ff0; }    p.info { background:blue; }

#info和E#info  id选择器，匹配所有id属性等于footer的元素         #info { background:#ff0; }   p#info { background:#ff0; }
</pre>
</div>
<h2><span style="font-size: 14pt;">2. 组合选择器</span></h2>
<div class="cnblogs_Highlighter">
<pre><code> E,F         多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔         div,p { color:#f00; }

 E F         后代元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔    li a { font-weight:bold;

 E &gt; F     子元素选择器，匹配所有E元素的子元素F                            div &gt; p { color:#f00; }
 
 E + F     毗邻元素选择器，匹配所有紧随E元素之后的同级元素F                  div + p { color:#f00; }  </pre>
</div>
<p><span style="font-size: 16px;">注意：</span></p>
<ol>
<li>块级元素可以包含内联元素或<strong>某些</strong>块级元素，但内联元素不能包含块级元素，它只能包含其它内联元素。</li>
<li><strong>有几个特殊的块级元素只能包含内联元素，不能包含块级元素</strong>。如h1,h2,h3,h4,h5,h6,p,dt</li>
<li>li内可以包含div</li>
<li>块级元素与块级元素并列、内联元素与内联元素并列。</li>
</ol>
<h2><span style="font-size: 14pt;">3. 属性选择器</span></h2>
<div class="cnblogs_Highlighter">
<pre><code>E[att]              匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如&ldquo;[cheacked]&rdquo;。以下同。）   p[title] { color:#f00; }

 E[att=val]      匹配所有att属性等于&ldquo;val&rdquo;的E元素                                 div[class=&rdquo;error&rdquo;] { color:#f00; }
 
 E[att~=val]    匹配所有att属性具有多个空格分隔的值、其中一个值等于&ldquo;val&rdquo;的E元素      td[class~=&rdquo;name&rdquo;] { color:#f00; }

 E[attr^=val]   匹配属性值以指定值开头的每个元素                     div[class^="test"]{background:#ffff00;}

 E[attr$=val]   匹配属性值以指定值结尾的每个元素                     div[class$="test"]{background:#ffff00;}

 E[attr*=val]    匹配属性值中包含指定值的每个元素                     div[class*="test"]{background:#ffff00;}
</pre>
</div>
<h2><span style="font-size: 14pt;">4. 伪类</span></h2>
<p><span style="font-size: 16px;">CSS伪类是用来给选择器添加一些特殊效果。</span></p>
<p><span style="font-size: 16px;"><strong>anchor伪类：</strong>专用于控制链接的显示效果</span></p>
<div class="cnblogs_Highlighter">
<pre><code>a:link（没有接触过的链接）,用于定义了链接的常规状态。

a:hover（鼠标放在链接上的状态）,用于产生视觉效果。

a:visited（访问过的链接）,用于阅读文章，能清楚的判断已经访问过的链接。

a:active（在链接上按下鼠标时的状态）,用于表现鼠标按下时的链接状态。

伪类选择器 : 伪类指的是标签的不同状态:

           a ==&gt; 点过状态 没有点过的状态 鼠标悬浮状态 激活状态

a:link {color: #FF0000} /* 未访问的链接 */

a:visited {color: #00FF00} /* 已访问的链接 */

a:hover {color: #FF00FF} /* 鼠标移动到链接上 */

a:active {color: #0000FF} /* 选定的链接 */ 格式: 标签:伪类名称{ css代码; }
</pre>
</div>
<p><span style="font-size: 16px;"><strong>before after</strong>伪类 ：</span></p>
<div class="cnblogs_Highlighter">
<pre><code>:before    p:before       在每个&lt;p&gt;元素之前插入内容
:after     p:after        在每个&lt;p&gt;元素之后插入内容

p:before        在每个 &lt;p&gt; 元素的内容之前插入内容                    p:before{content:"hello";color:red}
p:after         在每个 &lt;p&gt; 元素的内容之前插入内容                    p:after{ content:"hello"；color:red}
</pre>
</div>
<h2><span style="font-size: 14pt;">5. CSS的优先级</span></h2>
<p><span style="font-size: 16px;">所谓CSS优先级，即是指CSS样式在浏览器中被解析的先后顺序。</span></p>
<div class="cnblogs_Highlighter">
<pre><code>样式表中的特殊性描述了不同规则的相对权重，它的基本规则是：
1 内联样式表的权值最高                    style=""－－－－－－－－－－－－1000；
2 统计选择符中的ID属性个数。          #id    －－－－－－－－－－－－－100
3 统计选择符中的CLASS属性个数。   .class －－－－－－－－－－－－－10
4 统计选择符中的HTML标签名个数。 p       -－－－－－－－－－－－－-1
</pre>
</div>
<p><span style="font-size: 16px;">按这些规则将数字符串逐位相加，就得到最终的权重，然后在比较取舍时按照从左到右的顺序逐位比较。</span></p>
<h2><span style="font-size: 14pt;">6. CSS的继承性</span></h2>
<p><span style="font-size: 16px;">继承是CSS的一个主要特征，它是依赖于祖先-后代的关系的。继承是一种机制，它允许样式不仅可以应用于某个特定的元素，还可以应用于它的后代。例如一个BODY定义了的颜色值也会应用到段落的文本中。</span></p>
<div class="cnblogs_Highlighter">
<pre><code>1、文内的样式优先级为1000，所以始终高于外部定义。这里文内样式指形如&lt;div style="color:red&gt;blah&lt;/div&gt;的样式，而外部定义指经由&lt;link&gt;或&lt;style&gt;卷标定义的规则。

2、有!important声明的规则高于一切。

3、如果!important声明冲突，则比较优先权。

4、如果优先权一样，则按照在源码中出现的顺序决定，后来者居上。

5、由继承而得到的样式没有specificity的计算，它低于一切其它规则(比如全局选择符*定义的规则)。

6、有一些属性不能被继承，如：border, margin, padding, background等。
</pre>
</div>
<div class="cnblogs_Highlighter">
<pre><code>.head-box{
	width: 100%;
	background-color: blue !important;
}</pre>
</div>
<h1><span style="font-size: 18pt;">四、常用属性</span></h1>
<h2><span style="font-size: 14pt;">1. 颜色属性</span></h2>
<div class="cnblogs_Highlighter">
<pre><code>&lt;div style="color:blueviolet"&gt;ppppp&lt;/div&gt;
 
&lt;div style="color:#ffee33"&gt;ppppp&lt;/div&gt;
 
&lt;div style="color:rgb(255,0,0)"&gt;ppppp&lt;/div&gt;
 
&lt;div style="color:rgba(255,0,0,0.5)"&gt;ppppp&lt;/div&gt;
</pre>
</div>
<h2><span style="font-size: 14pt;">2. 字体属性</span></h2>
<div class="cnblogs_Highlighter">
<pre><code>font-size: 20px/50%/larger
 
font-family:'Lucida Bright'
 
font-weight: lighter/bold/border

font-style: oblique
</pre>
</div>
<h2><span style="font-size: 14pt;">3. 背景属性</span></h2>
<div class="cnblogs_Highlighter">
<pre><code>background-color: cornflowerblue

background-image: url('1.jpg');

background-repeat: no-repeat;(repeat:平铺满)

background-position: right top（20px 20px）;(横向：left center right)(纵向：top center bottom)

      简写：&lt;body style="background: 20px 20px no-repeat #ff4 url('1.jpg')"&gt;

                &lt;div style="width: 300px;height: 300px;background: 20px 20px no-repeat #ff4 url('1.jpg')"&gt;
</pre>
</div>
<h2><span style="font-size: 14pt;">4. 文本属性</span></h2>
<div class="cnblogs_Highlighter">
<pre><code>font-size: 10px;

text-align: center;   横向排列

line-height: 200px;   文本行高 通俗的讲，文字高度加上文字上下的空白区域的高度 50%:基于字体大小的百分比

vertical-align:－4px  设置元素内容的垂直对齐方式 ,只对行内元素有效，对块级元素无效

text-indent: 150px;   首行缩进
letter-spacing: 10px;
word-spacing: 20px;
text-transform: capitalize;
</pre>
</div>
<h2><span style="font-size: 14pt;">5. 边框属性</span></h2>
<div class="cnblogs_Highlighter">
<pre><code>border-style: solid;
 
border-color: chartreuse;
 
border-width: 20px;
 
简写：border: 30px rebeccapurple solid;
</pre>
</div>
<h2><span style="font-size: 14pt;">6. 列表属性</span></h2>
<div class="cnblogs_Highlighter">
<pre><code>ul,ol{   list-style: decimal-leading-zero;
         list-style: none; &lt;br&gt;         list-style: circle;
         list-style: upper-alpha;
         list-style: disc; }
</pre>
</div>
<h2><span style="font-size: 14pt;">7. display属性</span></h2>
<table class="dataintable">
<tbody>
<tr>
<td>none</td>
<td>此元素不会被显示。</td>
</tr>
<tr>
<td>block</td>
<td>此元素将显示为块级元素，此元素前后会带有换行符。</td>
</tr>
<tr>
<td>inline</td>
<td>默认。此元素会被显示为内联元素，元素前后没有换行符。</td>
</tr>
<tr>
<td>inline-block</td>
<td>行内块元素。（CSS2.1 新增的值）</td>
</tr>
</tbody>
</table>
<div class="cnblogs_Highlighter">
<pre class="brush:html;collapse:true;;gutter:true;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        a{
            display: inline-block;
            background-color: #2459a2;
            width: 100px;
            height: 100px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;a&gt;111&lt;/a&gt;
&lt;a&gt;222&lt;/a&gt;
&lt;a&gt;333&lt;/a&gt;

&lt;/body&gt;
&lt;/html&gt;
</pre>
</div>
<p><img src="./images/前端-CSS0.png" alt="" /></p>
<p>inline-block默认的空格符就是标签与标签之间的空隙造成的。</p>
<p>(1) 我们可以通过margin:-3px来解决，但是</p>
<p>1.我们布局肯定很多元素，不可能每个都添加margin负这样维护成本太大了</p>
<p>2.我们线上代码如果压缩，那么我们就不存在哪个4px的问题了，那么我们的margin负就回造成布局混乱！</p>
<p>(2)我们可以给几个标签加一个父级div，然后：</p>
<div class="cnblogs_Highlighter">
<pre><code>div{word-spacing:-5px}</pre>
</div>
<h2><span style="font-size: 14pt;">8. 行内外边距</span></h2>
<ul>
<li><strong>margin:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。</strong></li>
<li><strong>padding: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 用于控制内容与边框之间的距离； &nbsp;&nbsp;</strong></li>
<li><strong>Border(边框) &nbsp; &nbsp; 围绕在内边距和内容外的边框。</strong></li>
<li><strong>Content(内容) &nbsp; 盒子的内容，显示文本和图像。</strong></li>
</ul>
<p><span style="font-size: 15px;">边框在默认情况下会定位于浏览器窗口的左上角，但是并没有紧贴着浏览器的窗口的边框，这是因为body本身也是一个盒子（外层还有html），在默认情况下， &nbsp; body距离html会有若干像素的margin，具体数值因各个浏览器不尽相同，所以body中的盒子不会紧贴浏览器窗口的边框了，为了验证这一点，加上：</span></p>
<div class="cnblogs_Highlighter">
<pre><code>body{
    border: 1px solid;
    background-color: cadetblue;
}</pre>
</div>
<p class="p1"><span class="s1">&gt;&gt;&gt;&gt;解决方法：</span></p>
<div class="cnblogs_Highlighter">
<pre><code>body{
    margin: 0;
}
</pre>
</div>
<p><span style="font-size: 16px;"><strong>margin collapse（边界塌陷或者说边界重叠）</strong></span></p>
<p><span style="font-size: 15px;">外边距的重叠只产生在普通流文档的上下外边距之间，这个看起来有点奇怪的规则，其实有其现实意义。设想，当我们上下排列一系列规则的块级元素（如段 &nbsp; &nbsp; 落P）时，那么块元素之间因为外边距重叠的存在，段落之间就不会产生双倍的距离。</span></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1兄弟div：上面div的margin-bottom和下面div的margin-top会塌陷，也就是会取上下两者margin里最大值作为显示值</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2父子div &nbsp;&nbsp;&nbsp;</p>
<p><em>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</em>&nbsp;if &nbsp;父级div中没有 border，padding，inline content，子级div的margin会一直向上找，直到找到某个标签包括border，padding，inline content中的其中一个，然后按此div 进行margin；</p>
<div class="cnblogs_Highlighter">
<pre><code>解决方法
1: border:1px solid transparent
2:  padding:1px
3: over-flow:hidden; </pre>
</div>
<h2><span style="font-size: 14pt;">9. float属性</span></h2>
<p><span style="font-size: 16px;">先来了解一下block元素和inline元素在文档流中的排列方式。</span></p>
<p>　　block元素通常被现实为独立的一块，独占一行，多个block元素会各自新起一行，默认block元素宽度自动填满其父元素宽度。block元素可以设置width、height、margin、padding属性；</p>
<p>　　inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。inline元素设置width、height属性无效。inline元素的margin和padding属性。水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。</p>
<ul>
<li>常见的块级元素有 div、form、table、p、pre、h1～h5、dl、ol、ul 等。</li>
<li>常见的内联元素有span、a、strong、em、label、input、select、textarea、img、br等</li>
</ul>
<p><strong>所谓的文档流</strong>，指的是元素排版布局过程中，元素会自动从左往右，从上往下的流式排列。</p>
<p><strong>脱离文档流</strong>，也就是将元素从普通的布局排版中拿走，其他盒子在定位的时候，<strong>会当做脱离文档流的元素不存在而进行定位</strong>。</p>
<p><strong>只有绝对定位absolute和浮动float才会脱离文档流。</strong></p>
<p>&nbsp; &nbsp;&nbsp;&nbsp;---部分无视和完全无视的区别？需要注意的是，使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围(可以说是部分无视)。而对于使用absolute position脱离文档流的元素，其他盒子与其他盒子内的文本都会无视它。(可以说是完全无视)</p>
<h4><strong>浮动的表现</strong></h4>
<p>&nbsp; &nbsp; &nbsp; 定义：浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流中的浮动框之后的块框表现得就像浮动框不存在一样。（注意这里是块框而不是内联元素；浮动框只对它后面的元素造成影响）</p>
<p><strong>注意 当初float被设计的时候就是用来完成文本环绕的效果，所以文本不会被挡住，这是float的特性，即float是一种不彻底的脱离文档流方式。</strong>无论多么复杂的布局，其基本出发点均是：&ldquo;<strong>如何在一行显示多个div元素</strong>&rdquo;。</p>
<p class="p1"><strong>现象1:</strong></p>
<p class="p1"><span class="s1">&nbsp; &nbsp; &nbsp; 假如某个div元素A是浮动的，如果A元素上一个元素也是浮动的，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素上一个元素是标准流中的元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。此外，浮动的框之后的block元素元素会认为这个框不存在，但其中的文本依然会为这个元素让出位置。&nbsp;浮动的框之后的inline元素，会为这个框空出位置，然后按顺序排列。</span></p>
<p class="p1"><strong>现象2:</strong></p>
<p>　　(1)左右结构div盒子重叠现象，一般是由于相邻两个DIV一个使用浮动一个没有使用浮动。如上面的例1：相邻的两个盒子box2向左浮动、box3未浮动。一个使用浮动一个没有导致DIV不是在同个&ldquo;平面&rdquo;上，但内容不会照成覆盖现象，只有DIV形成覆盖现象。</p>
<p>　　解决方法：要么都不使用浮动；要么都使用float浮动；要么对没有使用float浮动的DIV设置margin样式。</p>
<p>　　(2)上下结构div盒子重叠现象</p>
<div class="cnblogs_Highlighter">
<pre class="brush:html;collapse:true;;gutter:true;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;
         * {
             margin:0;padding:0;
         }
        .container{
            border:1px solid red;width:300px;
        }
        #box1{
            background-color:green;float:left;width:100px;height:100px;
        }
        #box2{
            background-color:deeppink; float:right;width:100px;height:100px; 
        }
         #box3{
             background-color:pink;height:40px;
         }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

        &lt;div class="container"&gt;
                &lt;div id="box1"&gt;box1 向左浮动&lt;/div&gt;
                &lt;div id="box2"&gt;box2 向右浮动&lt;/div&gt;
        &lt;/div&gt;
        &lt;div id="box3"&gt;box3&lt;/div&gt;
&lt;/body&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
</div>
<p>例子如上：.container和box3的布局是上下结构，上图发现box3跑到了上面，与.container产生了重叠，但文本内容没有发生覆盖，只有div发生覆盖现象。这个原因是因为第一个大盒子里的子元素使用了浮动，脱离了文档流，导致.container没有被撑开。box3认为.container没有高度（未被撑开），因此跑上去了。</p>
<p>解决方法：</p>
<p>1、要么给.container设置固定高度，一般情况下文字内容不确定多少就不能设置固定高度，所以一般不能设置&ldquo;.container&rdquo;高度(当然能确定内容多高，这种情况下&ldquo;.container是可以设置一个高度即可解决覆盖问题。</p>
<p>2、要么清除浮动。</p>
<h4><span style="font-size: 16px;">清除浮动</span></h4>
<p>在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。</p>
<div class="cnblogs_Highlighter">
<pre><code>clear语法：
clear : none | left | right | both
取值：
none : 默认值。允许两边都可以有浮动对象
left : 不允许左边有浮动对象
right : 不允许右边有浮动对象
both : 不允许有浮动对象
但是需要注意的是：clear属性只会对自身起作用，而不会影响其他元素。如果一个元素的右侧有一浮动对象，而这个元素设置了不允许右边有浮动对象，即clear：right，则这个元素会自动下移一格，达到本元素右边没有浮动对象的目的。</pre>
</div>
<p>方法一（推荐）：</p>
<div class="cnblogs_Highlighter">
<pre><code>.clearfix:after {             &lt;----在类名为&ldquo;clearfix&rdquo;的元素内最后面加入内容； 
    content: ".";                 &lt;----内容为&ldquo;.&rdquo;就是一个英文的句号而已。也可以不写。 
    display: block;               &lt;----加入的这个元素转换为块级元素。 
    clear: both;                  &lt;----清除左右两边浮动。 
    visibility: hidden;           &lt;----可见度设为隐藏。注意它和display:none;是有区别的。visibility:hidden;仍然占据空间，只是看不到而已； 
    line-height: 0;               &lt;----行高为0； 
    height: 0;                    &lt;----高度为0； 
    font-size:0;                  &lt;----字体大小为0； 
} 
.clearfix { *zoom:1;}         &lt;----这是针对于IE6的，因为IE6不支持:after伪类，这个神奇的zoom:1让IE6的元素可以清除浮动来包裹内部元素。    </pre>
</div>
<p>整段代码就相当于在浮动元素后面跟了个宽高为0的空div，然后设定它clear:both来达到清除浮动的效果。&nbsp;<br />之所以用它，是因为，你不必在html文件中写入大量无意义的空标签，又能清除浮动。&nbsp;<br /><br />话说回来，你这段代码真是个累赘啊，这样写不利于维护。&nbsp;<br />只要写一个.clearfix就行了，然后在需要清浮动的元素中 添加clearfix类名就好了。&nbsp;<br />如：</p>
<div class="cnblogs_Highlighter">
<pre><code>&lt;div class="head clearfix"&gt;&lt;/div&gt;</pre>
</div>
<p>方法二：</p>
<div class="cnblogs_Highlighter">
<pre><code>overflow:hidden;
</pre>
</div>
<p><strong>overflow</strong>：hidden的含义是超出的部分要裁切隐藏，float的元素虽然不在普通流中，但是他是浮动在普通流之上的，可以把普通流元素+浮动元素想象成一个立方体。如果没有明确设定包含容器高度的情况下，它要计算内容的全部高度才能确定在什么位置hidden，这样浮动元素的高度就要被计算进去。这样包含容器就会被撑开，清除浮动。</p>
<h2><span style="font-size: 14pt;">10. position属性</span></h2>
<h4><span style="font-size: 16px;"><strong>1 static</strong></span></h4>
<p><strong>static 默认值，无定位，不能当作绝对定位的参照物，并且设置标签对象的left、top等值是不起作用的的。</strong></p>
<h4><span style="font-size: 16px;"><strong>2 &nbsp;position: relative／absolute</strong></span></h4>
<p><strong>&nbsp; &nbsp;&nbsp;</strong><strong>relative</strong>&nbsp;相对定位。相对定位是相对于该元素在文档流中的原始位置，即以自己原始位置为参照物。有趣的是，即使设定了元素的相对定位以及偏移值，元素还占有着原来的位置，即占据文档流空间<strong>。对象遵循正常文档流，</strong>但将依据top，right，bottom，left等属性在正常文档流中偏移位置。而其层叠通过z-index属性定义。</p>
<p>注意：position：relative的一个主要用法：方便绝对定位元素找到参照物。</p>
<h4><strong>&nbsp; &nbsp; absolute&nbsp;</strong>绝对定位。</h4>
<p>&nbsp; &nbsp; &nbsp; 定义：设置为绝对定位的元素框从文档流完全删除，并相对于最近的已定位祖先元素定位，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块（即body元素）。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。</p>
<p>重点：如果父级设置了position属性，例如position:relative;，那么子元素就会以父级的左上角为原始点进行定位。这样能很好的解决自适应网站的标签偏离问题，即父级为自适应的，那我子元素就设置position:absolute;父元素设置position:relative;，然后Top、Right、Bottom、Left用百分比宽度表示。</p>
<p>&nbsp; &nbsp; &nbsp; 另外，对象脱离正常文档流，使用top，right，bottom，left等属性进行绝对定位。而其层叠通过z-index属性定义。</p>
<p>总结：参照物用相对定位，子元素用绝对定位，并且保证相对定位参照物不会偏移即可。</p>
<h4><span style="font-size: 16px;"><strong>3 &nbsp;position:fixed</strong></span></h4>
<p>&nbsp; &nbsp; &nbsp; &nbsp; fixed：对象脱离正常文档流，使用top，right，bottom，left等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动。而其层叠通过z-index属性 定义。 注意点： 一个元素若设置了 position:absolute | fixed; 则该元素就不能设置float。这 是一个常识性的知识点，因为这是两个不同的流，一个是浮动流，另一个是&ldquo;定位流&rdquo;。但是 relative 却可以。因为它原本所占的空间仍然占据文档流。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;在理论上，被设置为fixed的元素会被定位于浏览器窗口的一个指定坐标，不论窗口是否滚动，它都会固定在这个位置。</p>
<h4><span style="font-size: 16px;">4&nbsp;<strong>仅使用margin属性布局绝对定位元素</strong></span></h4>
<p>此情况，margin-bottom 和margin-right的值不再对文档流中的元素产生影响，因为该元素已经脱离了文档流。另外，不管它的祖先元素有没有定位，都是以文档流中原来所在的位置上偏移参照物。&nbsp;&nbsp;<br />　　图9中，使用margin属性布局相对定位元素。<br />　　层级关系为：<br />　　&lt;div &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; position:relative;<br />　　&lt;div&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-没有设置为定位元素，不是参照物<br />　　&lt;div&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-没有设置为定位元素，不是参照物<br />　　&lt;div box1<br />　　&lt;div box2 &mdash;&mdash;&ndash;position:absolute;&nbsp;margin-top:50px; margin-left:120px;<br />　　&lt;div box3<br />　　效果图：</p>
<p>　　<img src="./images/前端-CSS1.png" alt="" /></p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>