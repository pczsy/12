<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Web前端篇：CSS常用格式化排版、盒模型、浮动、定位、背景边框属性' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Web前端篇：CSS常用格式化排版、盒模型、浮动、定位、背景边框属性</center></div><div class='banquan'>原文出处:本文由博客园博主是阿凯啊提供。<br/>
原文连接:https://www.cnblogs.com/xujunkai/p/10993083.html</div><br>
    <div class="toc">
    <p class="toc-title">目录</p>
    <div class="toc-list">
        <ul>
        <li><a href="#web前端篇css常用格式化排版盒模型浮动定位背景边框属性">Web前端篇：CSS常用格式化排版、盒模型、浮动、定位、背景边框属性</a><ul>
        <li><a href="#常用格式化排版">1.常用格式化排版</a></li>
        <li><a href="#css盒模型">2.CSS盒模型</a></li>
        <li><a href="#浮动">3.浮动</a></li>
        <li><a href="#定位">4.定位</a></li>
        <li><a href="#背景属性和边框属性">5.背景属性和边框属性</a></li>
        <li><a href="#网页中规范和错误问题">6.网页中规范和错误问题</a></li>
        <li><a href="#显示方式">7.显示方式</a></li>
        <li><a href="#section"></a></li>
        </ul></li>
        </ul>
    </div>
</div>
<h1 id="web前端篇css常用格式化排版盒模型浮动定位背景边框属性">Web前端篇：CSS常用格式化排版、盒模型、浮动、定位、背景边框属性</h1>
<h2 id="常用格式化排版">1.常用格式化排版</h2>
<h4 id="字体的属性">1.字体的属性</h4>
<ul>
<li><p>设置字体属性：</p>
<pre><code><code>body{font-family:&quot;Microsoft Yahei&quot;}

body{font-family:&quot;Microsoft Yahei&quot;,&quot;宋体&quot;,&quot;黑体&quot;}
#备选字体可以有无数个，那么浏览器在去解析这个代码的时候，是从左往右解析的，如果没有微软雅黑，再去找宋体，最后黑体。</code></pre></li>
<li><p>字体大小：</p>
<ul>
<li>最常用的像素单位：px、em、rem，这里咱们先介绍一种单位，px。</li>
<li><strong>px</strong>:像素是指由图像的小方格组成的，这些小方块都有一个明确的位置和被分配的色彩数值，小方格颜色和位置就决定该图像所呈现出来的样子。</li>
</ul></li>
<li><p>字体颜色：</p>
<ul>
<li>颜色表示方法在css中有三种方式：
<ul>
<li>英文单词表示法：red/green/blue</li>
<li>rgb表示法</li>
<li>十六进制表示法</li>
</ul></li>
</ul></li>
<li><p>字体样式font-style</p>
<ul>
<li><p>网站中的字体分为了普通字体和斜体字体，我们可以使用font-style属性来设置对应的字体样式。</p></li>
<li><p>normal正常,italic斜体,oblique斜体</p>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        p{
            font-style:italic;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;你好&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre></li>
</ul></li>
<li><p>字体粗细</p>
<ul>
<li><p>font-weight</p>
<table>
<thead>
<tr class="header">
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>normal</td>
<td>普通的字体粗细，默认</td>
</tr>
<tr class="even">
<td>bold</td>
<td>加粗的字体粗细</td>
</tr>
<tr class="odd">
<td>lighter</td>
<td>比普通字体更细的字体</td>
</tr>
<tr class="even">
<td>bolder</td>
<td>比bold更粗的字体</td>
</tr>
<tr class="odd">
<td>100~900</td>
<td>400表示normal</td>
</tr>
</tbody>
</table></li>
</ul></li>
<li><p>文本属性：</p>
<ul>
<li><p>text-decoration</p>
<table>
<thead>
<tr class="header">
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>none</td>
<td>无文本的修饰</td>
</tr>
<tr class="even">
<td>underline</td>
<td>文本下划线</td>
</tr>
<tr class="odd">
<td>overline</td>
<td>文本上划线</td>
</tr>
<tr class="even">
<td>line-through</td>
<td>穿过文本的线，<del>可以模拟删除线</del>。</td>
</tr>
</tbody>
</table></li>
</ul></li>
<li><p>文本缩进</p>
<ul>
<li>我们通常写文章的时候，首字母要空两格。那么我们需要使用</li>
<li>text-indent,它的属性值是像素(px、em、rem)单位。</li>
</ul></li>
<li><p>行间距</p></li>
<li><p>line-height:数值px/em</p></li>
<li><p>纵纹字间距/字母间距</p>
<ul>
<li>letter-spacing:数值px;</li>
<li>word-spacing:数值px;</li>
</ul></li>
<li><p>文本对齐</p>
<ul>
<li><p>text-align</p>
<table>
<thead>
<tr class="header">
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>left</td>
<td>文本左对齐，默认</td>
</tr>
<tr class="even">
<td>right</td>
<td>文本右对齐</td>
</tr>
<tr class="odd">
<td>center</td>
<td>中心对齐</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ul>
<h4 id="pxemrem">2.px,em,rem</h4>
<ul>
<li><p>px单位的名称为像素，它是一个固定大小的单元，像素的计算是针对（电脑/手机）屏幕的，一个像素（1px）就是（电脑/手机）屏幕上的一个点，即屏幕分辨率的最小分割。</p></li>
<li><p>它是相对于当前对象内文本的字体尺寸；如果没有人为设置当前对象内文本的字体尺寸，那么它相对的是浏览器默认的字体尺寸</p></li>
<li><p>rem只相对于根目录，即HTML元素。所以只要在html标签上设置字体大小，文档中的字体大小都会以此为参照标准，一般用于自适应布局。</p>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        *{
            padding:0;
            margin:0;
        }
        html{
            font-size:20px
        }
        .box{
            font-size:12px;
            width:20rem;
            height:20rem;
            background-color: red;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></li>
</ul>
<h2 id="css盒模型">2.CSS盒模型</h2>
<ul>
<li><p>常用块元素由：</p>
<pre><code><code>p,h1-h6,div,ul,ol,tr,li,form</code></pre></li>
<li><p>常用内联元素由：</p>
<pre><code><code>a,span,em,i,strong,u,</code></pre></li>
<li><p>常见的内联块元素</p>
<pre><code><code>input img</code></pre></li>
</ul>
<table>
<thead>
<tr class="header">
<th>标签类别</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>块状元素</td>
<td>1.独自占据整一行 2.可以设置宽高</td>
</tr>
<tr class="even">
<td>内联元素</td>
<td>1.所有的内联元素在一行内显示 2.不可以设置宽高</td>
</tr>
<tr class="odd">
<td>行内块元素</td>
<td>1.在一行内显示 2.可以设置宽高</td>
</tr>
</tbody>
</table>
<ul>
<li>盒模型常用属性：
<ul>
<li>盒子模型中有四个属性：内容的宽高、内边距、外边距、边框。</li>
</ul></li>
</ul>
<p><img src="./images/Web前端篇：CSS常用格式化排版、盒模型、浮动、定位、背景边框属性0.png" /></p>
<h4 id="padding">1.padding</h4>
<ul>
<li><p>padding有四个方向，分别描述四个方向的padding。</p>
<pre><code><code>padding-top:10px;
padding-right:3px;
padding-bottom:50px;
padding-left:70px;</code></pre></li>
<li><p>综合属性，多个属性用空格隔开。</p>
<pre><code><code>/*上 右 下 左 四个方向*/
padding: 20px 30px 40px 50px ;
/*上 左右  下*/
padding: 20px 30px 40px;
/* 上下 左右*/
padding: 20px 30px;
/*上下左右*/
padding: 20px;</code></pre></li>
</ul>
<h4 id="border">2.border</h4>
<ul>
<li><p>盒子模型的边框，在样式表中称为border。我们知道呢，我们用的手机，都会有手机壳。手机壳的样式、颜色、薄厚程度等都是这个壳的形态。同样呢，盒模型的边框也有三要素：<strong>粗细 线性样式 颜色</strong>。</p>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;border的使用&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        .box{
            width: 200px;
            height: 200px;
            /*1像素实线且红色的边框*/
            border: 1px solid red;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<ul>
<li><strong>按照三要素书写border</strong></li>
</ul>
<pre><code><code>border-width:3px;
border-style:solid;
border-color:red;
/*上面三句代码相当于一句代码：border:3px solid red;*/
/*同样,也可以分别设置边框四个方向的粗细 线性样式 颜色,跟padding的四个方向一样。*/
/*上下5px  左右10px*/
border-width:5px 10px;
/*上：实现  右：点状  下：双线 左：虚线*/
border-style: solid dotted double dashed;
/*上：红色 左右：绿色 下：黄色*/
border-color: red green yellow;</code></pre>
<ul>
<li>按照方向划分</li>
</ul>
<pre><code><code>border-top-width: 10px;
border-top-color: red;
border-top-style: solid;
border-right-width: 10px;
border-right-color: red;
border-right-style: solid;
border-bottom-width: 10px;
border-bottom-color: red;
border-bottom-style: solid;
border-left-width: 10px;
border-left-color: red;
border-left-style:solid;

相当于border:10px solid red;</code></pre></li>
<li><p>清除默认边框：border:none;或者border:0; outline:none;</p></li>
</ul>
<h4 id="margin">3.margin</h4>
<ul>
<li><p>在盒子模型中称为外边距，样式表中叫margin。表示盒子到另一个盒子的距离。既然是两者之间的距离，那么就会产生水平之间的距离和垂直之间的距离。同样情况下，外边距也有四个方向，跟padding类似。</p></li>
<li><p><strong>水平方向的外边距</strong></p>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;水平方向外边距&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        span:nth-child(1){
            background-color: green;
            margin-right: 20px;
        }
        span:nth-child(2){
            background-color: red;
            margin-left: 30px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;span class=&quot;box_l&quot;&gt;左盒子&lt;/span&gt;&lt;span class=&quot;box_r&quot;&gt;右盒子&lt;/span&gt;
&lt;/body&gt;
&lt;/html&gt;
#nth-child(1)，获取span子类，参数为第1个。</code></pre></li>
<li><p><strong>垂直方向外边距</strong></p>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        div{
            width: 200px;
            height: 200px;

        }
        #box1{
            background-color: red;
            margin-bottom: 30px;
        }
        #box2{
            background-color: black;
            margin-top: 100px
        }
        #box3{
            background-color: yellowgreen;
        }
        #box3 p{
            background-color: goldenrod;
            margin-top: 30px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- margin 在垂直方向上会出现外边距合并现象，塌陷。以设置的最大的magrin距离为基准--&gt;
  &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt;
    &lt;div id=&quot;box2&quot;&gt;&lt;/div&gt;</code></pre></li>
</ul>
<pre><code><code>  
  注意：盒模型的外边距水平方向上不会出现问题，在垂直方向上会出现“**外边距合并**”的现象。
  </code></pre>
<p>什么是外边距合并呢？在有些文献中说这种现象叫塌陷问题。只有在垂直方向上，当两个同级的盒子，在垂直方向上设置了margin之后，那么以较大者为准。</p>
<p>在网页排版中，外边距合并的问题也会时常出现，我们如何避免出现这种问题呢？</p>
<p>很简单，我们如果想让上下的两个盒子中间有间距，只需要设置一个盒子的一个方向即可。没必要去碰触外边距塌陷的问题，还得找解决问题的方法，得不偿失。</p>
<h2 id="浮动">3.浮动</h2>
<ul>
<li><p>浮动是网页布局中非常重要的一个属性。那么<code>浮动</code>这个属性一开始设计的初衷是为了网页的<code>文字环绕效果</code>。</p></li>
<li><p>文字环绕现象</p>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;水平方向外边距&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        html{
            font-size:24px;
        }
        img{
            width:20rem;
        }
        #sep{
            float: left;
        }
        p{
            border:1px solid red;
            text-indent:2rem;
            font-size:1rem;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;sep&quot;&gt;
        &lt;img src=&quot;https://i1.mifile.cn/a4/xmad_15590487108559_JOpcA.jpg&quot; alt=&quot;加载失败&quot; title=&quot;王源&quot;&gt;
    &lt;/div&gt;
    &lt;p&gt;
        我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我
        我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我
        我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我
        我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我
        我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我
        我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我
        我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我
        我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我
        我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我
        我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我
        我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我
        我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我
        我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我
        我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我去我
    &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></li>
</ul>
<h4 id="浮动属性">1.浮动属性</h4>
<ul>
<li>css样式表中用float来表示，它有</li>
</ul>
<table>
<thead>
<tr class="header">
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>none</td>
<td>表示不浮动，所有之前讲解的HTML标签默认不浮动</td>
</tr>
<tr class="even">
<td>left</td>
<td>左浮动</td>
</tr>
<tr class="odd">
<td>right</td>
<td>右浮动</td>
</tr>
<tr class="even">
<td>inherit</td>
<td>继承父元素的浮动属性</td>
</tr>
</tbody>
</table>
<pre><code><code>    &lt;meta charset=&quot;UTF-8&quot;/&gt;
    &lt;title&gt;浮动属性用法&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        .left{
            width: 200px;
            height: 200px;
            background-color: red;
            color: #fff;
            /*左浮动*/
             float:left;
        }
        .right{
            width: 200px;
            height: 200px;
            background-color: green;
            color: #fff;
            /*右浮动*/
             float:right;
        }
    &lt;/style&gt;
    &lt;div class=&quot;left&quot;&gt;左边的盒子&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;右边的盒子&lt;/div&gt;</code></pre>
<h4 id="浮动现象">2.浮动现象</h4>
<pre><code><code>我们之前说浮动的设计初衷是为了做”文字环绕效果“。那么我们就来看一下如果对盒子设置了浮动，会产生什么现象？
1浮动的元素脱离了标准文档流，即脱标
2浮动的元素互相贴靠
3浮动的元素会产生”字围“效果
4浮动元素有收缩效果</code></pre>
<h4 id="浮动的破坏性">3.浮动的破坏性</h4>
<ul>
<li><p>浮动之后效果展示：<br />
<img src="./images/Web前端篇：CSS常用格式化排版、盒模型、浮动、定位、背景边框属性1.png" /></p></li>
<li>由此可见，浮动之后，盒子因为脱离了标准文档流，它撑不起父盒子的高度，导致父盒子<code>高度塌陷</code>。如果网页中出现了这种问题，会导致我们整个网页的布局紊乱。我们一定要去解决这种父盒子高度塌陷的问题。</li>
<li><p>那么如何解决<em>浮动给网页带来的问题</em>？</p></li>
</ul>
<h4 id="清除浮动的方式">4.清除浮动的方式</h4>
<p>我们知道浮动具有破坏性，它能使父盒子高度塌陷、导致页面紊乱。那么在css布局中对于浮动的解决方案有四种：</p>
<h5 id="父盒子设置固定高度">1.父盒子设置固定高度</h5>
<ul>
<li>给父盒子设置固定高度，缺点不灵活，后期不易维护。应用领域导航栏。</li>
</ul>
<h5 id="内墙法">2.内墙法</h5>
<ul>
<li>在浮动元素的后面加一个空的块级元素(通常是div),并且该元素设置clear:both属性。</li>
<li>clear属性，字面意思就是清除，那么both,就是清除浮动元素对我左右两边的影响。如下示例</li>
</ul>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        *{
            padding: 0;
            margin: 0;
        }
        .father{
            width: 800px;
            margin: 100px auto;
            border: 1px solid #000;
        }
        .child1{
            width: 200px;
            height: 400px;
            background-color: red;
            float: left;
        }
        .child2{
            width: 300px;
            height: 200px;
            background-color: green;
            float: right;
        }
        .clear{
            clear: both;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--内墙法：给最后一个浮动元素的
后面添加一个空的块级标签，并且设
置该标签的属性为clear:both;--&gt;
    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;child1&quot;&gt;A盒子&lt;/div&gt;
        &lt;div class=&quot;child2&quot;&gt;B盒子&lt;/div&gt;
        &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;

    &lt;/div&gt;</code></pre>
<ul>
<li>存在问题：冗余过长。</li>
</ul>
<h5 id="伪元素清除法推荐使用">3.伪元素清除法（推荐使用）</h5>
<ul>
<li><p>伪元素选择器很简单。就像伪类一样，让伪元素添加了选择器，但不是描述特殊的状态，他们允许您为元素的某些部分设置样式。在这里只介绍一个。</p></li>
<li><p>语法：</p>
<pre><code><code>p::after{
    /*p::after{}一定要有content。表示在p元素内部的最后面的添加内容*/
    content:&#39;...&#39;
}</code></pre></li>
<li><p>示例：</p>
<pre><code><code> ...
 .clearfix::after{
            content:&#39;&#39;;
            display: block;
            clear: both;
            /*visibility: hidden;*/
            /*height: 0;*/
        }

    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;father clearfix&quot;&gt;
        &lt;div class=&quot;child1&quot;&gt;盒子A&lt;/div&gt;
        &lt;div class=&quot;child2&quot;&gt;盒子B&lt;/div&gt;

    &lt;/div&gt;</code></pre></li>
</ul>
<h5 id="overflowhidden">4.overflow:hidden</h5>
<ul>
<li>CSS属性overflow定义一个元素的内容太大而无法适应盒子的时候该做什么。它是overflow-x和overflow-y的简写属性</li>
</ul>
<table>
<thead>
<tr class="header">
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>visible</td>
<td>默认值。内容不会被修剪，会呈现在元素框之外</td>
</tr>
<tr class="even">
<td>hidden</td>
<td>内容会被修剪，并且其余内容不可见</td>
</tr>
<tr class="odd">
<td>scroll</td>
<td>内容会被修剪，浏览器会显示滚动条以便查看其余内容</td>
</tr>
<tr class="even">
<td>auto</td>
<td>由浏览器定夺，如果内容被修剪，就会显示滚动条</td>
</tr>
<tr class="odd">
<td>inherit</td>
<td>规定从父元素继承overflow属性的值</td>
</tr>
</tbody>
</table>
<ul>
<li>hidden</li>
</ul>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        body{
            overflow: hidden;
        }
        .box{
            width: 300px;
            height: 300px;
            border: 1px solid #000;
            overflow: hidden;

        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;box&quot;&gt;
    此处有一篇1万字文章
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
#注意：此处内容会被修建，并且其余内容不可见</code></pre>
<ul>
<li>overflow:hidden||auto|scroll属性之后，它会形成一个BFC区域，我们叫做它为<code>块级格式化上下文</code>。BFC只是一个规则。它对浮动定位都很重要。浮动定位和清除浮动只会应用于同一个BFC的元素。</li>
<li>浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。</li>
</ul>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        *{
            padding: 0;
            margin: 0;
        }
        .father{
            width: 800px;
            margin: 100px auto;
            border: 1px solid #000;
            /*一旦设置一个Box盒子 除了overflow：visible；
            它会形成一个BFC,BFC它有布局规则： 它会让内部浮动元素计算高度*/
            overflow: hidden;
        }
        .child1{
            width: 200px;
            height: 400px;
            background-color: red;
            float: left;
        }
        .child2{
            width: 300px;
            height: 200px;
            background-color: green;
            /*float: right;*/
            /*overflow: hidden;*/
            float: left;
        }


    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;div class=&quot;father &quot;&gt;
        &lt;div class=&quot;child1&quot;&gt;A盒子&lt;/div&gt;
        &lt;div class=&quot;child2&quot;&gt;B盒子&lt;/div&gt;
    &lt;/div&gt;



&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h4 id="深入理解bfc">5.深入理解BFC：</h4>
<ul>
<li><p>了解BFC</p>
<ul>
<li><p>（1）B: BOX即盒子，页面的基本构成元素。分为 inline 、 block 和 inline-block三种类型的BOX</p>
<p>（2）FC: Formatting Context是W3C的规范中的一种概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>
<p>（3）常见的 Formatting Context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)</p></li>
</ul></li>
</ul>
<h5 id="bfc布局">1.BFC布局：</h5>
<pre><code><code>1.内部的Box会在垂直方向，一个接一个地放置。
2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠
3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
4.BFC的区域不会与float 元素重叠。
5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
6.计算BFC的高度时，浮动元素也参与计算</code></pre>
<h5 id="哪那些元素会生成bfc">2.哪那些元素会生成BFC</h5>
<pre><code><code>1.根元素
2.float属性不为none
3.position为absolute或fixed
4.display为inline-block
5.overflow不为visible</code></pre>
<h5 id="display属性">3.display属性</h5>
<ul>
<li><p>display属性设置元素如何显示</p>
<table>
<thead>
<tr class="header">
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>none</td>
<td>此元素不会被显示</td>
</tr>
<tr class="even">
<td>block</td>
<td>此元素将显示为块级元素，此元素前后会带有换行</td>
</tr>
<tr class="odd">
<td>inline</td>
<td>默认，此元素会被显示为内联元素，元素前后没有换行</td>
</tr>
<tr class="even">
<td>inline-block</td>
<td>行内块，将元素显示为行内块元素，设置属性后，其他的行内块级元素会排在同一行。</td>
</tr>
<tr class="odd">
<td>table-cell</td>
<td>此元素会作为一个表格单元格显示</td>
</tr>
</tbody>
</table></li>
</ul>
<h2 id="定位">4.定位</h2>
<ul>
<li>定位是一个相当复杂的话题，在去深入理解定位之前，我们先来聊一下之前我们的标准文档流下的布局。</li>
<li>应用:网页中小广告，返回顶部的UI。</li>
</ul>
<h4 id="position属性">1.Position属性</h4>
<ul>
<li>定位方式：top,right,bottom,left属性决定该元素的最终位置。</li>
</ul>
<table>
<thead>
<tr class="header">
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>static</td>
<td><strong>默认。静态定位</strong>， 指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 和 <code>z-index</code>属性无效。</td>
</tr>
<tr class="even">
<td>relative</td>
<td><strong>相对定位</strong>。 元素先放置在未添加定位时的位置，在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）</td>
</tr>
<tr class="odd">
<td>absolute</td>
<td><strong>绝对定位</strong>。不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并</td>
</tr>
<tr class="even">
<td>fixed</td>
<td><strong>固定定位</strong>。 不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变</td>
</tr>
</tbody>
</table>
<h4 id="静态定位">2.静态定位</h4>
<ul>
<li>静态定位意味着“元素默认显示文档流的位置”。没有任何变化。</li>
</ul>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;静态定位&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        .positioned{
            position: static;
            background-color: red;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p class=&quot;positioned&quot;&gt;我是静态定位的元素&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h4 id="相对定位">3.相对定位</h4>
<ul>
<li>相对定位的元素是在文档中的正常位置的偏移，但是不会影响其他元素的偏移。</li>
<li>参考点：以自身原来的位置进行定位，可以使用top,left,right,bottom对元素进行偏移。</li>
<li>现象：
<ul>
<li>不脱离标准文档流，单独设置盒子相对定位之后，。不用top,left,right,bottom对元素进行偏移，那么与普通的盒子没什么区别。</li>
<li>有压盖现象。用<code>top,left,right,bottom</code>对元素进行偏移之后，明显定位的元素的层级高于没有定位的元素(用top,left,right,bottom层级低)。</li>
</ul></li>
</ul>
<h4 id="绝对定位">4.绝对定位</h4>
<ul>
<li>相对定位的元素并没有脱离标准文档流，而绝对定位的元素则脱离了文档流。在标准文档流中，如果一个盒子设置了绝对定位，那么该元素不占据空间。并且绝对定位元素相对于最近的非static祖先元素定位。当这样的祖先元素不存在时，则相对于根元素页面的左上角进行定位。</li>
<li>参考点：
<ul>
<li>相对于最近的非static祖先元素定位，如果没有非static祖先元素，那么以页面左上角进行定位。</li>
</ul></li>
</ul>
<h4 id="应用">5.应用</h4>
<ul>
<li>相对定位的盒子，一般用于“子绝父相”，布局模式参考</li>
</ul>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .box{
            width: 400px;
            height: 500px;
            background-color:red;
            position: relative;
        }
        div .c1{
            width: 200px;
            height: 200px;
            background-color:blue;
            position: absolute;
            top: 20px;
            left: 20px;
        }
        div .c2{
            width: 100px;
            height: 100px;
            background-color:greenyellow;
            position: absolute;
            top: 20px;
            left: 20px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;box&quot;&gt;
        &lt;div class=&quot;c1&quot;&gt;子1&lt;/div&gt;
        &lt;div class=&quot;c2&quot;&gt;子2&lt;/div&gt;

    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<ul>
<li>子绝父相</li>
</ul>
<h4 id="z-index">6.z-index:</h4>
<ul>
<li>z-index有以下几个规则：
<ul>
<li>z-index只应用在定位元素，默认z-index:auto;</li>
<li>z-index取值为整数，数值越大，它的层级越高。</li>
<li>如果元素设置了定位，没有设置z-index,那么谁写在后面的表示谁层级越高。</li>
<li>从父现象，通常布局方案我们采用<code>子绝父相</code>，比较的是父元素的z-index值，哪个父元素的z-index值越大，表示子元素的层级越高。</li>
</ul></li>
</ul>
<h2 id="背景属性和边框属性">5.背景属性和边框属性</h2>
<ul>
<li>背景属性值</li>
</ul>
<table>
<thead>
<tr class="header">
<th>属性值</th>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>background-color</td>
<td>d单侧颜色法，RGB，十六进制</td>
<td>s设置元素的背景颜色</td>
</tr>
<tr class="even">
<td>background-image</td>
<td>url(&quot;wy.png&quot;)</td>
<td>给一个元素设置一个或多个背景图像</td>
</tr>
<tr class="odd">
<td>background-position</td>
<td>top,left,center,百分比，px</td>
<td>为每一个背景图片设置初始位置</td>
</tr>
<tr class="even">
<td>background-repreat</td>
<td>repeat-x</td>
<td>repeat-y</td>
</tr>
</tbody>
</table>
<ul>
<li>background-image设置背景图片</li>
</ul>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .bg{
            width: 400px;
            height: 400px;
            border:1px solid blue;
            background-image:url(&quot;wy.jpg&quot;)
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;bg&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<ul>
<li><p>background-repeat背景图像</p>
<ul>
<li>属性值：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>数值值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>repeat</td>
<td><strong>默认值</strong>。表示背景图水平和垂直方向都平铺</td>
</tr>
<tr class="even">
<td>no-repeat</td>
<td>表示背景图水平和处置方向都不平铺</td>
</tr>
<tr class="odd">
<td>repeat-x</td>
<td>表示背景图只有水平方向上平铺</td>
</tr>
<tr class="even">
<td>repeat-y</td>
<td>表示背景图只有垂直方向上平铺</td>
</tr>
</tbody>
</table></li>
</ul>
<pre class="css"><code>.bg{
    width: 1000px;
    height: 1000px;
    border:1px solid blue;
    background-image:url(&quot;sj6.jpg&quot;);
    background-repeat:repeat-x;/*沿着轴方向平铺*/
}</code></pre>
<ul>
<li><p>bacground-position背景图定位</p>
<ul>
<li><p>语法：</p>
<pre><code><code>background-position:x y;
background-position:position position</code></pre></li>
<li><p>取值</p>
<pre><code><code>关键字取值：
    top ,right,bottom,left,center
长度值取值：
    px,em
百分比：
    50%</code></pre></li>
<li><p>示例</p>
<pre class="css"><code>background-position:0 0;
/*左上角显示*/</code></pre>
<pre class="css"><code>background-position:top right; /*背景图像在右上角*/</code></pre>
<pre class="css"><code>background-position:top center; /*背景图像上方居中显示*/</code></pre>
<pre class="css"><code>background-position:center center;/*背景图像居中显示*/</code></pre>
<ul>
<li>设置长度单位：</li>
</ul>
<p><img src="./images/Web前端篇：CSS常用格式化排版、盒模型、浮动、定位、背景边框属性2.png" /></p>
<pre class="css"><code>background-position:50px 100px;</code></pre>
<ul>
<li>设置为负值：</li>
</ul>
<pre class="css"><code>background-position:-20px -30px;</code></pre></li>
</ul></li>
</ul>
<h4 id="雪碧图">2.雪碧图</h4>
<ul>
<li>CSS雪碧图技术：即CSS Sprite,也有人叫它CSS精灵图，是一种图像拼合技术。该方法是将多个小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。</li>
</ul>
<p><img src="./images/Web前端篇：CSS常用格式化排版、盒模型、浮动、定位、背景边框属性3.png" /></p>
<ul>
<li>优点：
<ul>
<li>有效的减少HTTP请求数量</li>
<li>加速内容</li>
</ul></li>
<li>雪碧图的实现原理
<ul>
<li>它通过css的背景属性的backrground-position的来控制雪碧图的显示。</li>
<li>控制一个层，可显示的区域范围大消息，通过一个窗口，进行背景图的移动。</li>
</ul></li>
</ul>
<h4 id="border-radius">3.border-radius</h4>
<ul>
<li>传统的圆角生成方案，必须使用多张图片作为背景图案。css3的出现，使得我们再也不必浪费时间去制作这些图片，并且还有其他多个优点：
<ul>
<li>减少维护的工作量。图片文件的生成、更新、编写网页代码，这些工作都不再需要了。</li>
<li>提高网页性能。由于不必再发出多条的HTTP请求，网页的载入速度将变快</li>
<li>增加视觉可靠性。（网络拥堵、服务器出错、网速过慢等等），背景图片会下载失败，导致视觉效果不佳。CSS3就不会发生这种情况。</li>
</ul></li>
</ul>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .bor-radius{
            width: 400px;
            height: 400px;
            border-radius:20px;
            background-color: red;
    }
    &lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;bor-radius&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<ul>
<li><p>显示效果如下：</p>
<p><img src="./images/Web前端篇：CSS常用格式化排版、盒模型、浮动、定位、背景边框属性4.png" /></p></li>
<li><p>单角设置：</p>
<ul>
<li><p>border-top-left-radius</p></li>
<li><p>border-top-right-radius</p></li>
<li><p>border-bottom-right-radius</p></li>
<li><p>border-bottom-left-radius</p></li>
<li><p>示例：</p>
<pre><code><code>border-bottom-left-radius：</code></pre>
<p><img src="./images/Web前端篇：CSS常用格式化排版、盒模型、浮动、定位、背景边框属性5.png" /></p></li>
</ul></li>
<li><p>border-radius效果实现一个无边框圆</p>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .cicle{
            width: 200px;
            height: 200px;
            background-color: red;
            border-radius:50%;
        }
    &lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;cicle&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></li>
<li><p>制作一半的圆</p>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .cicle{
            width: 200px;
            height: 100px;
            background-color: red;
            border-top-left-radius: 100px;
            border-top-right-radius: 100px;
        }
    &lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;cicle&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><img src="./images/Web前端篇：CSS常用格式化排版、盒模型、浮动、定位、背景边框属性6.png" /></p></li>
</ul>
<h4 id="盒子阴影">4.盒子阴影</h4>
<ul>
<li><p>通过box-shadow属性设置元素的阴影</p></li>
<li><p>语法：</p>
<pre class="css"><code>box-shadow: h-shadow v-shadow blur color inset;</code></pre>
<table>
<thead>
<tr class="header">
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>h-shadow</td>
<td>必需。水平阴影的位置。允许负值</td>
</tr>
<tr class="even">
<td>v-shadow</td>
<td>必需。垂直阴影的位置。允许负值。</td>
</tr>
<tr class="odd">
<td>blur</td>
<td>可选。模糊距离。</td>
</tr>
<tr class="even">
<td><em>color</em></td>
<td>可选。阴影的颜色。</td>
</tr>
<tr class="odd">
<td>inset</td>
<td>可选。将外部阴影 (outset) 改为内部阴影。</td>
</tr>
</tbody>
</table></li>
</ul>
<pre class="css"><code>        .bg{
            width: 400px;
            height: 400px;
            border:1px solid blue;
            background-image:url(&quot;sj6.jpg&quot;);
            background-repeat:no-repeat;
            background-position:50px 100px;
            box-shadow:5px 5px 20px red;
        }</code></pre>
<h2 id="网页中规范和错误问题">6.网页中规范和错误问题</h2>
<ul>
<li><p>css命名规范：</p>
<p>参考链接<a href="http://www.divcss5.com/jiqiao/j4.shtml#no2" class="uri">http://www.divcss5.com/jiqiao/j4.shtml#no2</a></p></li>
<li><p>项目目录规范：</p>
<p><img src="./images/Web前端篇：CSS常用格式化排版、盒模型、浮动、定位、背景边框属性7.png" /></p></li>
<li><p>确定错误位置</p>
<ul>
<li>假如错误影响了整体布局，则可以逐个删除div块，直到删除某个div块后显示恢复正常，即可确定错误发生的位置。这样我们可以更精准的找到错误点，进行排错。</li>
</ul></li>
<li><p>是否重设了默认的样式?</p>
<ul>
<li>制作网页时，我们要清除掉默认的元素的padding和margin，使得我们更易去计算盒模型的大小。</li>
</ul></li>
</ul>
<h2 id="显示方式">7.显示方式</h2>
<h4 id="行内元素水平居中显示">1.行内元素水平居中显示</h4>
<ul>
<li><p>通过line-hinght + text-align</p>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        p{
            width: 200px;
            height: 200px;
            background-color: #666;
            color:red;
            line-height: 200px;
            text-align:center;
        }
    &lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;
        帅气的阿凯哥
    &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></li>
</ul>
<p><img src="./images/Web前端篇：CSS常用格式化排版、盒模型、浮动、定位、背景边框属性8.png" /></p>
<ul>
<li><p>通过给父元素设置display:table-cell,并且设置vertical-align:middle</p>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        span{
            width: 200px;
            height: 200px;
            background-color: #666;
            color:red;
            text-align:center;
            display: table-cell;
            vertical-align:middle;
        }
    &lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;
    &lt;span&gt;
        &lt;span&gt;你好啊&lt;/span&gt;
    &lt;/span&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><img src="./images/Web前端篇：CSS常用格式化排版、盒模型、浮动、定位、背景边框属性9.png" /></p></li>
</ul>
<h4 id="块级元素水平垂直居中">2.块级元素水平垂直居中</h4>
<ul>
<li><p>第一种：position+margin</p>
<ul>
<li>position,子绝父相，margin自动设置外边距</li>
</ul>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .father{
            width: 200px;
            height: 200px;
            background-color: red;
            position: relative;
        }
        .child{
            position: absolute;
            width: 100px;
            height: 100px;
            background-color: blue;
            margin:auto;
            top:0;
            left:0;
            bottom:0;
            right:0;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;child&quot;&gt;居中盒子&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></li>
<li><p>第二种：display:table-cell</p>
<pre class="css"><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .father{
            width: 200px;
            height: 200px;
            background-color: red;
            display:table-cell;
            vertical-align:middle;
            text-align:center;
        }
        .child{
            width: 100px;
            height: 100px;
            background-color: green;
            display:inline-block;
            vertical-align:middle;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;child&quot;&gt;居中盒子&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></li>
<li><p>第三种：position</p></li>
</ul>
<pre class="css"><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        .father{
            width: 200px;
            height: 200px;
            background-color: red;
            position: relative;
        }
        .child{
            width: 100px;
            height: 100px;
            background-color: green;
            position: absolute;
            left: 50%;
            top: 50%;
            margin-left: -50px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;child&quot;&gt;我是个居中的盒子&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h2 id="section"></h2>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>